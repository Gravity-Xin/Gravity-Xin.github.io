---
title: etcd学习笔记-示例源码
date: 2018-12-05 16:53:16
categories:
- Distributed System
tags:
- Raft
- Etcd
- WAL
- Snapshot
comments: true
---

在etcd的代码中，实现了raft协议，主要功能包括日志复制、选主、Snapshot、成员变更等功能，raft库还定义了一个`Storage`接口，包含对LogEntry的相关操作，需要由raft库的使用者实现
同时，代码里还提供了一个使用了raft库的例子，名为raftexample，该应用对外提供HTTP REST的KV存储接口

## 简单使用

* 编译

```shell
go build -o raftexample ./contrib/raftexample
```

* 启动集群

```shell
./raftexample --id 1 --cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379 --port 12380
./raftexample --id 2 --cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379 --port 22380
./raftexample --id 3 --cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379 --port 32380
```

* 读写数据

```shell
curl -L http://127.0.0.1:12380/my-key -XPUT -d bar
curl -L http://127.0.0.1:32380/my-key
```

* 集群变更

```shell
# 通知Leader增加一个节点
curl -L http://127.0.0.1:12380/4 -XPOST -d http://127.0.0.1:42379
# 启动新加入的节点
./raftexample --id 4 --cluster http://127.0.0.1:12379,http://127.0.0.1:22379,http://127.0.0.1:32379,http://127.0.0.1:42379 --port 42380 --join
# 通知Leader删除一个节点
curl -L http://127.0.0.1:12380/3 -XDELETE
# 关闭节点3
```

## 程序组成

程序中主要包含三个部分：KV存储、HTTP REST API服务、基于Raft的服务一致性实现

客户通过HTTP接口向应用发起请求，对于读请求，直接从应用的状态机中获取并返回；对于写请求，将请求传递到Raft库，Raft与多个节点进行通信达到一致性后，将已提交的KV对告知应用，应用将其保存到自己的状态机中

* KV存储

```Go
type kvstore struct {
    proposeC    chan<- string //应用和底层Raft库之间的通信管道，接口来自用户的请求并传递给Raft库
    mu          sync.RWMutex
    kvStore     map[string]string //应用的状态机，一个简单的KV，对应Raft库中已经被提交的KV对
    snapshotter *snap.Snapshotter //应该管理Snapshot的接口
}
```

* Raft库

```Go
// 应用层对Raft节点的描述
type raftNode struct {
    proposeC    <-chan string               //应用和底层Raft库之间的通信管道，接口来自用户的读写请求并传递给Raft库
    confChangeC <-chan raftpb.ConfChange    //应用和底层Raft库之间的通信管道，接口来自用户成员变更请求并传递给Raft库
    commitC     chan<- *string              // 底层Raft库和应用之间的通信管道，底层Raft通过该管道通知应用准备提交KV
    errorC      chan<- error                // 底层Raft库和应用之间的通信管理，底层Raft通过该管道通知应用出现错误

    id          int                     // Raft节点ID
    peers       []string                // Raft其他节点URL
    join        bool                    // Raft节点是否需要加入一个新的集群
    waldir      string                  // WAL文件的目录
    snapdir     string                  // Snapshot文件的目录
    getSnapshot func() ([]byte, error)  // 应用层提供的进行Snapshot的入口函数
    lastIndex   uint64                  // 启动时，Raft中LogEntry的最大Index

    confState     raftpb.ConfState
    snapshotIndex uint64
    appliedIndex  uint64

    node        raft.Node                   // Raft底层库的接口
    raftStorage *raft.MemoryStorage         // Raft节点的内存存储
    wal         *wal.WAL                    // Raft节点的WAL日志

    snapshotter      *snap.Snapshotter          // Raft节点的Snapshotter
    snapshotterReady chan *snap.Snapshotter     // 通知应用层snapshotter创建完毕的管道

    snapCount uint64
    transport *rafthttp.Transport
    stopc     chan struct{} // signals proposal channel closed
    httpstopc chan struct{} // signals http server to shutdown
    httpdonec chan struct{} // signals http server shutdown complete
}

// Raft底层库的接口，描述集群中的单个节点
type Node interface {
    // Tick increments the internal logical clock for the Node by a single tick. Election
    // timeouts and heartbeat timeouts are in units of ticks.
    Tick()

    Campaign(ctx context.Context) error //将节点状态改为candidate，然后发起选主操作

    Propose(ctx context.Context, data []byte) error //发起Append Log操作，可能会失败，因此需要应用层重试

    ProposeConfChange(ctx context.Context, cc pb.ConfChange) error //发起成员变更操作，当应用EntryConfChange的Entry类型时，应用层需要调用ApplyConfChange

    Step(ctx context.Context, msg pb.Message) error // 使用指定的msg来更新状态机

    Ready() <-chan Ready // 返回一个可读的chan，Ready封装了各种状态，应用通过Ready获取了状态之后，需要调用Advance

    Advance() // 应用层调用该方法告知Raft节点已经同步到最新的Ready状态

    ApplyConfChange(cc pb.ConfChange) *pb.ConfState // 将成员变更操作应用到本地节点

    TransferLeadership(ctx context.Context, lead, transferee uint64) //尝试将Leader交给transferee

    // ReadIndex request a read state. The read state will be set in the ready.
    // Read state has a read index. Once the application advances further than the read
    // index, any linearizable read requests issued before the read request can be
    // processed safely. The read state will have the same rctx attached.
    ReadIndex(ctx context.Context, rctx []byte) error

    // Status returns the current status of the raft state machine.
    Status() Status
    // ReportUnreachable reports the given node is not reachable for the last send.
    ReportUnreachable(id uint64)
    // ReportSnapshot reports the status of the sent snapshot. The id is the raft ID of the follower
    // who is meant to receive the snapshot, and the status is SnapshotFinish or SnapshotFailure.
    // Calling ReportSnapshot with SnapshotFinish is a no-op. But, any failure in applying a
    // snapshot (for e.g., while streaming it from leader to follower), should be reported to the
    // leader with SnapshotFailure. When leader sends a snapshot to a follower, it pauses any raft
    // log probes until the follower can apply the snapshot and advance its state. If the follower
    // can't do that, for e.g., due to a crash, it could end up in a limbo, never getting any
    // updates from the leader. Therefore, it is crucial that the application ensures that any
    // failure in snapshot sending is caught and reported back to the leader; so it can resume raft
    // log probing in the follower.
    ReportSnapshot(id uint64, status SnapshotStatus)

    Stop() // 关闭当前节点
}

type Ready struct { //保存了多种状态的数据
    // The current volatile state of a Node.
    // SoftState will be nil if there is no update.
    // It is not required to consume or store SoftState.
    *SoftState

    pb.HardState // 发送消息之前需要进行持久化的状态

    // ReadStates can be used for node to serve linearizable read requests locally
    // when its applied index is greater than the index in ReadState.
    // Note that the readState will be returned when raft receives msgReadIndex.
    // The returned is only valid for the request that requested to read.
    ReadStates []ReadState

    Entries []pb.Entry // 发送消息之前需要持久化的Entry

    Snapshot pb.Snapshot // 需要持久化的Snapshot

    // CommittedEntries specifies entries to be committed to a
    // store/state-machine. These have previously been committed to stable
    // store.
    CommittedEntries []pb.Entry

    // Messages specifies outbound messages to be sent AFTER Entries are
    // committed to stable storage.
    // If it contains a MsgSnap message, the application MUST report back to raft
    // when the snapshot has been received or has failed by calling ReportSnapshot.
    Messages []pb.Message

    // MustSync indicates whether the HardState and Entries must be synchronously
    // written to disk or if an asynchronous write is permissible.
    MustSync bool
}
```

* HTTP REST API服务

```Go
func (h *httpKVAPI) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    key := r.RequestURI
    switch {
    case r.Method == "PUT": //PUT 用来更新Key
        v, err := ioutil.ReadAll(r.Body)
        if err != nil {
            log.Printf("Failed to read on PUT (%v)\n", err)
            http.Error(w, "Failed on PUT", http.StatusBadRequest)
            return
        }

        h.store.Propose(key, string(v)) // 将更新请求发送到底层Raft库
        w.WriteHeader(http.StatusNoContent) // 在此处不等待Raft库完成更新操作，直接返回；后续的读请求可能会得到旧的Value
    case r.Method == "GET": //GET 用来读取Key
        if v, ok := h.store.Lookup(key); ok { // 直接从应用层的状态机中查询
            w.Write([]byte(v))
        } else {
            http.Error(w, "Failed to GET", http.StatusNotFound)
        }
    case r.Method == "POST": //POST 用来执行成员变更-增加成员操作
        url, err := ioutil.ReadAll(r.Body)
        if err != nil {
            log.Printf("Failed to read on POST (%v)\n", err)
            http.Error(w, "Failed on POST", http.StatusBadRequest)
            return
        }

        nodeId, err := strconv.ParseUint(key[1:], 0, 64)
        if err != nil {
            log.Printf("Failed to convert ID for conf change (%v)\n", err)
            http.Error(w, "Failed on POST", http.StatusBadRequest)
            return
        }

        cc := raftpb.ConfChange{
            Type:    raftpb.ConfChangeAddNode,
            NodeID:  nodeId,
            Context: url,
        }
        h.confChangeC <- cc // 将变更请求提交给Raft库
        w.WriteHeader(http.StatusNoContent) // 与更新Key一样，不等待Raft库完成集群变更操作
    case r.Method == "DELETE": // DELETE 用来执行成员变更-删除成员操作
        nodeId, err := strconv.ParseUint(key[1:], 0, 64)
        if err != nil {
            log.Printf("Failed to convert ID for conf change (%v)\n", err)
            http.Error(w, "Failed on DELETE", http.StatusBadRequest)
            return
        }

        cc := raftpb.ConfChange{
            Type:   raftpb.ConfChangeRemoveNode,
            NodeID: nodeId,
        }
        h.confChangeC <- cc
        w.WriteHeader(http.StatusNoContent)
    default:
        w.Header().Set("Allow", "PUT")
        w.Header().Add("Allow", "GET")
        w.Header().Add("Allow", "POST")
        w.Header().Add("Allow", "DELETE")
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
    }
}
```

## 启动流程

```Go
main()
  |- flag.Pasre()                                                                   解析启动参数，如cluster、id、port、join
  |- make(chan string)                                                              初始化proposeC管道，用于应用层向Raft发送KV数据
  |- make(chan raftpb.ConfChange)                                                   初始化confChangeC管道，用于应用层向Raft发送成员变更消息
  |- newRaftNode()                                                                  新建raftNode对象，返回comitC、errorC的管道和snapshotterReady管道
  |  |                                                                              前者是Raft告知应用层已被提交的消息、出现错误的管道，后者是告知snapshotter已被建立的管道
  |  |- raftNode{}                                                                  新建raftNode对象，将各个管道复制，初始化各个参数
  |  |- go raftNode.startRaft()                                                     启动节点
  |  |  |- os.Mkdir()                                                               如果snapDir目录不存在，则创建该目录
  |  |  |- snap.New()                                                               创建snapshotter对象，并通过snapshotterReady将该对象传出
  |  |  |- wal.Exist()                                                              判断WAL日志目录是否存在，用于确定该节点是否是第一次启动
  |  |  |- raftNode.replayWAL()                                                     读取snapshot，并将其赋值到raftNode.wal中
  |  |  |  |- raftNode.loadSnapshot()                                               加载snapshot
  |  |  |  |  |- raftNode.snapshotter.Load()                                        使用节点的snapshotter对象来加载snapshot
  |  |  |  |  |  |- snapshotter.snapNames()                                         遍历snapshot目录下的文件，并按照文件名称进行排序
  |  |  |  |  |  |- snap.loadSnap()                                                 依次加载每一个文件，只要成功加载一个就返回结果
  |  |  |  |  |  |  |- snap.Read()                                                  读取文件内容并进行反序列化，使用CRC和snapshot内部格式判断snapshot的有效性
  |  |  |  |- raftNode.openWAL()                                                    根据生成的snapshot中的Index和Term，生成可读的WAL对象
  |  |  |  |  |- wal.Open()                                                         读取WAL文件，生成WAL对象
  |  |  |  |  |  |- wal.openAtIndex()                                               从指定Index读取WAL文件
  |  |  |  |  |  |  |- wal.readWALNames()                                           查找WAL目录下的WAL文件
  |  |  |  |  |  |  |- wai.searchIndex()                                            查找每一个WAL的Index
  |  |  |  |- raftNode.wal.ReadAll()                                                读取所有的WAL
  |  |  |  |- raft.NewMemoryStorage()                                               使用raft中的内存存储，并将其赋值到raftNode.raftStorage中
  |  |  |  |- raftNode.raftStorage.ApplySnapshot()                                  将snapshot存入到内存存储中，实际上是更新内存存储的snapshot成员并添加一个最新的LogEntry
  |  |  |  |- raftNode.raftStorage.SetHardState()                                   设置内存存储的hardState成员
  |  |  |  |- raftNode.raftStorage.Append()                                         将LogEntry添加到内存存储中，根据LogEntry的Index和Term决定将Append哪些LogEntry
  |  |  |  |- raftNode.lastIndex                                                    设置lastIndex
  |  |  |- raft.Config{}                                                            生成Raft配置，包括节点ID、超时时间等等
  |  |  |
  |  |  |- raft.RestartNode()                                                       如果之前WAL目录已经存在，则直接重启服务，返回raft.Node对象赋值给raftNode.node
  |  |  |
  |  |  |- raft.StartNode()                                                         如果之前WAL目录不存在，则启动服务

```