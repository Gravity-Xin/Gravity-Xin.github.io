---
title: 数据结构-Tree
date: 2019-03-05 15:19:27
categories: 
- 编程技术
tags: 
- 二叉树
- 二叉查找树
- AVL
- 红黑树
- B树
- B+树
- B*树
- Trie树
- Huffman树
comments: true
---

## 二叉树

- 定义:每一个节点至多有两颗子树，子树有左右之分

- 特点
  - 第i层最多含有2^(i-1)个节点
  - 深度为k的二叉树，最多还有2^k-1个节点
  - 如果叶子节点数为n0，度为2的节点数为n2，则n0=n2+1

- 满二叉树: 除了最后一层节点无子节点外，其他所有节点都有两个子节点

- 完全二叉树: 除最后一层外，其他层的所有节点数都达到最大数量，且最后一层的所有节点都连续集中在最左边

![img](/images/Tree数据结构之满-完全二叉树.png)

- 遍历
  - 先序遍历: 根 左子树 右子树
  - 中序遍历: 左子树 根 右子树
  - 后序遍历: 左子树 右子树 根

- 存储方式
  - 顺序存储: 利用数组来存储，仅仅适用于完全二叉树，如堆数据结构，此时父子节点的编号存在对应关系
![img](/images/Tree数据结构之顺序存储.png)
  - 链式存储: 最常见的存储方式，由于子节点可能为空，所以该方式比较浪费存储空间
![img](/images/Tree数据结构之链式存储.png)

## 二叉查找树

- 定义
  - 如果左子树不为空，则左子树上所有节点的值都小于根节点的值
  - 如果右子树不为空，则右子树上所有节点的值都大于根节点的值
  - 左右子树本身也是一颗二叉查找树

- 特点
  - 对其进行中序遍历，则得到一个有序的序列
  - 插入/查找操作的时间复杂度为O(logn)，最坏情况下为O(n) **原因在于在插入和删除元素时，没有保持树的平衡**
  - 二叉查找树的高度决定了二叉查找树的效率

- 查找过程
  - 如果根节点为空，则返回查找失败
  - 如果根节点的值等于查找值，返回成功
  - 如果查找的元素小于根节点，则到左子树中查找
  - 如果查找的元素大于根节点，则到右子树中查找

- 插入过程
  - 如果根节点为空，则插入的元素为根节点
  - 如果根节点的值等于查找值，返回失败
  - 如果插入的元素小于根节点，则插入到左子树中
  - 如果插入的元素大于根节点，则插入到右子树中

- 删除过程
  - 使用查找过程找到对应的节点P
  - 如果P节点的左右子树都为空，直接删除该节点并修改其父节点的指针值
![img](/images/Tree数据结构之二叉查找树的删除1.png)
  - 如果P节点的左子树或右子树为空，则让P节点的子节点与父节点相连，然后删除P节点即可
![img](/images/Tree数据结构之二叉查找树的删除2.png)
  - 如果P节点左右子树均不为空，则找到P右子树中最小的元素或者找到左子树中最大的元素，然后将其放到P节点位置即可
![img](/images/Tree数据结构之二叉查找树的删除3.png)

## 平衡二叉树

- 定义
  - 是对二叉查找树的改进，通过**在插入和删除过程中进行自平衡的操作，保证二叉树的高度为logn，从而提高查找效率**
  - 任意节点的左右两个子树的高度差的绝对值不超过1
  - 左右子树本身也是平衡二叉树

### AVL树

平衡二叉树的一种

- 特点
  - 插入/删除/查找的时间复杂度O(logn)
  - 在进行插入和删除时，需要通过一次或多次旋转操作来保持平衡，该树结构是高度平衡的

### 红黑树

平衡二叉树的一种

- 特点
  - 插入/删除/查找的时间复杂度O(logn)，需要通过自平衡操作来保证平衡
  - 每一个节点带有颜色属性，红色或黑色
  - 根节点和所有叶子节点都是黑色
  - 每一个红色节点必须含有两个黑色的子节点 **即从根节点要叶子节点之间的所有路径中不可以有两个连续的红色节点，即红节点的孩子不能是红节点**
  - **从任一节点到其每一个叶子节点的所有路径中都包含相同数目的黑色节点**
  - **从根节点到叶子节点的最长路径不多于最短路径的两倍**，该树结构是大致平衡的

![img](/images/Tree数据结构之红黑树.png)

## B树

- 定义
  - 中间节点最多只有M个子节点，M>2
  - 根节点的子节点数为[2, M]
  - 中间节点的子节点数为[M/2, M]
  - 每一个节点上存放至少M/2-1(向上取整)和至多M-1个关键字
  - 中间节点的关键字数量=指向子节点的指针数量-1
  - 中间节点的关键字为K[1], K[2], ... ,k[M-1]，且K[i]<K[i+1]
  - 中间节点指向子节点的指针为P[1], P[2], ... , P[M]，其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1], K[i])的子树

![img](/images/Tree数据结构之B树.png)

- 特点
  - 是一种用于查找的平衡树，但不是二叉树。节点的子节点数量可以超过2个，是一个更为一般的二叉查找树
  - 用于对排序后的数据进行存储，插入/删除/查找的时间复杂度为O(logn)
  - **平衡二叉树是通过在插入/删除过程中进行自平衡的操作保持树的平衡，从而提高查找效率；而B树是通过增加子节点的数量，减少树的高度来提高查找效率**

- 查找过程
  - 如果根节点为空，则返回查找失败
  - 如果根节点的值等于查找值，返回成功
  - 由于根节点的子节点是有序的，因此在根节点的子节点中进行顺序或者二分查找，如果找到查找值，返回成功；否则确定查找值位于Ki与Ki+1之间，此时Pi为根节点的第i个子节点
  - 取Pi作为根节点，重复上述查找过程

## B+树

- 定义
  - 是B树的变体，也是用于查找的平衡树，定义除了以下几点，其他与B树基本相同
  - 中间节点的指针数和关键字相同
  - 中间节点的子树指针P[i], 指向关键字属于[K[i], K[i+1])的子树
  - 所有叶子节点增加一个链指针
  - 所有关键字都出现在叶子节点

![img](/images/Tree数据结构之B+树.png)

- 特点
  - 所有关键字都出现在叶子节点，因此在进行查找时必须到达叶子节点才能命中，而B树可以在非叶子节点命中
  - 所有叶子节点之间形成一个链表，且链表中的关键字是有序的
  - 中间节点可以看做是叶子节点的索引层，叶子节点可以看做是存储关键字(数据)的数据层
  - **由于根节点和中间节点不存储数据，因此占用空间较小，更适合进行外部存储，比如磁盘，因为一次磁盘IO可以读取更多的节点数。同时，由于所有数据都在叶子节点上，可以方便进行范围查找，并且可以通过磁盘预读的方式和局部性原理减少磁盘IO的次数，提高查找效率**

- 查找过程
  - 和B树相同，只不过只有在叶子节点上才会命中

## 单词查找树

- 定义
  - 又叫Trie树，主要用于统计、排序和存储大量的字符串，常被搜索引擎用于文本词频统计
  - **使用字符串的公共前缀来减少查询时间**，最大限度减少无谓的字符串比较

![img](/images/Tree数据结构之单次查找树.png)

- 特点
  - 根节点不包含字符，其他节点只包含一个字符，即每一个节点最多有26个子节点
  - 从根节点到某一个节点，路径上经过的字符连接起来即为该节点对应的字符串
  - 每一个节点的所有子节点包含的字符都不相同

## 霍夫曼树

- 定义
  - 构造所有节点的带权路径之和最小的二叉树
  - 可用于进行霍夫曼编码

- 构造过程

![img](/images/Tree数据结构之霍夫曼树.png)

- 霍夫曼编码

![img](/images/Tree数据结构之霍夫曼编码.png)

## FAQ

- AVL、红黑树和B树、B+树的区别

都是用于查找的树结构，**AVL和红黑树是平衡二叉树，通过自平衡操作来实现树的平衡，提高查找效率；而B树、B+树是多叉树，通过降低树的高度来提交查找效率**

当数据量较小时，AVL和红黑树的性能很好；但是当数据量很大时，如数据库中的数据，性能则不够理想

原因在于当数据里很大时，此时内存不够用，需要将大部分的数据存储到磁盘之中，此时磁盘的IO就成为了性能瓶颈。AVL和红黑树的数据结构无法迎合磁盘IO中的预读机制，导致**在查询过程中需要h次磁盘IO，h为树的高度**。同时AVL和红黑树在插入和删除过程中需要进行自平衡的操作，如果此时部分数据在内存、部分数据在磁盘中时**无法完成自平衡操作**

而B树和B+树的设计迎合的磁盘IO的预读机制。通过在节点上添加多个子节点，**降低了树的高度，需要的磁盘IO次数变小**；同时在新建节点时，可以将**多个节点的大小等于磁盘上的一页，这样便可以通过磁盘预读机制，一次性读取多个节点，减少磁盘IO次数**

- B树和B+树的区别

B+树只在叶子节点上存放数据，因此查找时间复杂度固定为O(logn)，而B树查询的时间复杂度不定，与关键字在树中的位置有关，最好为O(1)

B+树叶子节点使用链表来组织，可以充分利用磁盘预读的空间局部性原理，减少磁盘IO数，同时可方便的进行**范围查询**；而B-树不方便进行范围查询

B+树的中间节点不存放数据，**节点占用空间更小，因此单次磁盘IO可以读取的节点数更大**，因此查找效率更高