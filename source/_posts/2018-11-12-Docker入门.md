---
title: Docker入门
date: 2018-11-12 10:58:35
categories: 
- Docker/K8S
tags: 
- Docker
- Image
- Container
- Network
- Volume
- Dockerfile
comments: true
---

## 基本概念

- 虚拟化的实现方式
  - 主机级别的虚拟化: 基于Hypervisor，模拟出一个完整的硬件平台，需要用户自行安装OS等软件，然后才能运行应用
  - 容器级别的虚拟化: 基于操作系统提供的接口
    - 使用Namespaces对进程(PID)、进程间通信(IPC)、网络(Network)、文件(Mount)、用户(User)、主机名/域名(UTS)等进行隔离
    - 使用ControlGroups对CPU、内存、DiskIO、NetworkIO等资源进行分组和控制

![img](/images/docker之虚拟机.png)

![img](/images/docker之容器化.png)

- 容器级别的虚拟化功能最早由LXC(LinuX Container)提供，但是LXC不易使用

- Docker简化了用户大规模使用容器技术的难度
  - 使用镜像文件来管理容器运行所需的数据
  - 对容器的创建、部署和删除等进行管理
  - `Build Once, Deploy AnyWhere`

- C/S架构: Client-Deamon

- Image: 镜像(静态)
  - 使用分层的文件系统，bootfs(引导文件系统)->rootfs(操作系统)
  - 使用联合加载技术在rootfs上面加载更多层的`只读文件系统`
  - 镜像名称: `用户名/仓库名(Repository):标签`

- Container: 容器(动态)
  - 交互式容器
  - 守护式容器
  - 写时复制特性，使用一个新的读写层来记录镜像的变化

- Registry: 镜像仓库
  - 本地
  - 远程 **必要时需要配置镜像加速器，如阿里云、网易、中科大等**

整体结构: ![Docker Architecture](/images/docker之基本架构.jpg)

## 常用命令

- 所有的命令按照Container、Image、Network、Volume等进行了分组，以便于记忆

- Container生命周期相关
  - `docker container run [OPTIONS] IMAGE [COMMNAD] [arg...]`: 创建容器并启动容器和运行命令
  - `docker container create [OPTIONS] IMAGE [COMMAND] [arg...]`: 创建容器但并不启动它
  - `docker container start|stop|restart [OPTIONS] CONTAINER [CONTAINER...]`: 启动|停止|重启容器
  - `docker container kill [OPTIONS] CONTAINER`: 想容器发送信号
  - `docker container rm [OPRIONS] CONTAINER [CONTAINER...]`: 删除容器
  - `docker container pause|unpause CONTAINER [CONTAINER...]`: 暂停|恢复容器
  - `docker container exec [OPTIONS] CONTAINER COMMAND [arg...]`: 在运行的容器中执行命令

![img](/images/docker之容器状态.png)

- Container管理相关
  - `docker container ls [OPTIONS]`: 列出容器
  - `docker container inspect [OPTIONS] CONTAINER`: 查看容器的元数据
  - `docker container top CONTAINER`: 查看容器中运行的进程
  - `docker container attach [OPTIONS] CONTANER`: 连接到正在运行的容器中
  - `docker container logs [OPTIONS] CONTAINER`: 查看容器中进程的日志
  - `docker container export [OPTIONS] CONTAINER`: 将容器中的文件系统打包为tar文件
  - `docker container commit [OPTIONS] CONTAINER`: 从指定容器创建一个新的镜像
  - `docker container cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH`: 文件从容器拷贝到宿主机
  - `docker container cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH`: 文件从宿主机拷贝到容器
  - `docker container diff CONTAINER`: 查看容器中文件结构的变化信息

- 本地Image管理相关

  - `docker image ls [OPTIONS]`: 列出本地镜像
  - `docker image rm [OPTIONS] IMAGE [IMAGE...]`: 删除镜像
  - `docker image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]`: 对本地的一个原始镜像进行标记，生成一个新的镜像
  - `docker image build [OPTIONS] PATH|URL|-`: 基于Dockerfile创建镜像
  - `docker image history [OPTIONS] IMAGE`: 查询镜像的创建历史
  - `docker image save [OPTIONS] IMAGE`: 将镜像保存为tar文件
  - `docker image import [OPTIONS] FILE|URL|- [REPOSITORY[:TAG]]`: 从tar文件中创建镜像

- Registry相关

  - `docker login [OPTIONS] [SERVER]`: 登录到镜像仓库
  - `docker logout`: 从镜像仓库登出
  - `docker image pull [OPTIONS] NAME[:TAG|@DIGEST]`: 从镜像仓库中拉取或更新镜像
  - `docker image push [OPTIONS] NAME[:TAG]`: 将本地镜像上传到镜像仓库
  - `docker search [OPTIONS]`: 搜索镜像

- Other
  - `docker info`: 查看Docker系统信息
  - `docker version`: 查看Docker版本

## 数据卷(Volume)

- 绕过联合文件系统（UFS）的目录，为一个或多个容器提交访问，方便进行数据共享和持久化操作
- 完全独立于容器的生成周期，删除容器时，不会删除其挂载的数据卷
- 本质上是宿主机上的目录或文件

为容器添加数据卷:

- 使用`docker run -v src:dest:ro`
  - src为宿主机相对路径
  - dest为容器内的绝对路径
  - ro为容器对数据卷的访问权限，表示只读

- 使用Dockerfile中的VOLUME ["/data"]指令创建匿名数据卷
  - /data为容器中的dest目录，而宿主机中的src目录则会在运行该镜像时由docker自动创建
  - 同一个镜像被多次运行时，宿主机的src目录是不同的
  - 这种方式创建的数据卷无法在不同容器中进行数据共享

![volume](/images/docker之数据卷.png)

数据卷容器:

创建一个挂载数据卷的容器，其它的容器通过挂载这个容器实现数据共享，那么该容器成为数据卷容器 **当不能访问宿主机目录时，可以通过数据卷容器进行数据共享**

- 使用数据卷容器: `docker run --volumes-from [CONTAINER]`
- 删除容器: `docker rm -v [CONTAINER]`，如果指定了-v选项，则会软删除与该容器关联的数据卷，**但是只有当该数据卷不再被任何容器使用后，数据卷本身才会被真正删除**

![volume contain](/images/docker之数据库卷器.png)

数据卷的备份与恢复:

- 备份: `docker run --volumes-from [CONTAINER] -v $PWD:/backup ubuntu tar cvf /backup/backup.tar [VOLUME]`
- 还原: `docker run --volumes-from [CONTAINER] -v $PWD:/backup ubuntu tar xvf /backup/backup.tar [VOLUME]`

![volume](/images/docker之数据卷的备份与恢复.png)

## 网络(Network)

Docker提供了五种网络模式

- Host: Docker容器加入宿主机所在的网络中，网络配置和宿主机一样，没有独立的IP地址 **本质是不使用Network Namespace对网络进行隔离**
- Container: Docker容器和一个已经存在的容器共享一个Network Namespace，而不是和宿主机共享 **本质是Network Namespace的共享，包括IP地址和端口范围**
- None: Docker容器中没有网卡，不使用网络
- Bridge(默认): Docker容器使用宿主机中创建的docker0虚拟网桥，有独立的IP地址 **本质是使用Network Namespace对网络进行隔离**
- 自定义网络

其中，在Bridge模式下，Docker会为所有的容器设置IP地址，并创建新的虚拟网桥`docker0`，并将启动的容器与该网桥相连。

- docker0 Docker默认使用的虚拟网桥(数据链路层)，可以对其设置IP地址(网络层)
- 启动容器时，会创建网络连接的两端，一端是容器内的eth0(以太网卡)，一端是运行Docker服务宿主机上docker0设备的veth*

![image](/images/docker之宿主机和容器的网络连接.png)

容器间的互联：

- 通过自定义network
    `docker network create -d bridge my-net`
    `docker run --network my-net`

容器与外部网络的互联

- 设置与宿主机的端口映射
    `docker run -p ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort`

## 编写Dockerfile

构建Docker镜像的方式:

- `docker container commit`: 通过容器构建
- `docker image build`: 通过Dockerfile文件构建

使用`alpine`来作为基础镜像，可以大大减小镜像的大小

Dockefile的组成

- Dockerfile是一个文本文件，其中包含了一条条的指令(Instruction)，每条指令构建一层
- `FROM image:tag`: 指定基础镜像，必须是第一条指令 **scratch空白镜像**
- `MAINTAINER name`: 指定镜像的作者信息
- `RUN`: 指定镜像构建过程中运行的命令 **每一个RUN命令都会在当前镜像的上层创建一个新的镜像用于执行该命令，因此为了避免镜像的臃肿，应该将RUN中的命令使用&&进行连结**
  - `RUN command param1 param2`: shell模式 -> /bin/bash command param1 param2
  - `RUN {"command", "param1", "param2"}`: exec模式 -> 可以指定其他shell来运行命令
- `EXPOSE port`: 指定运行该镜像的容器使用的端口，可指定多个 **在运行该镜像时，仍然需要再次指定容器的端口**
- `CMD`: 指定运行该镜像时，容器中默认运行的命令 **如果启动容器时，同时指定了命令，则CMD会被覆盖**
  - `CMD command param1 param2`: shell模式
  - `CMD {"command", "param1", "param2"}`: exec模式
  - `CMD {"param1", "param2"}`: 作为ENTRYPOINT指定的默认参数
- `ENTRYPOINT`: 与CMD指定类似 **如果运行容器时，同时指定了命令，则ENTRYPOINT不会被覆盖，除非使用了docker image run的--entrypoint参数**
  - `ENTRYPOINT command param1 param2`: shell模式
  - `ENTRYPOINT {"command", "param1", "param2"}`: exec模式
- `ADD src dest`: 将文件或目录复制到镜像中，src为构建目录的相对路径，dest为镜像中的绝对路径
- `COPY src dest`: 将文件或目录复制到镜像中，src为构建目录的相对路径，dest为镜像中的绝对路径 **如果时单纯的复制文件，推荐使用COPY指令**
- `VOLUME ["/data]`: 向镜像运行的容器中添加数据卷
- `WORKDIR path`: 设置容器中运行的命令的工作目录，与CMD和ENTRYPOIN指令配合使用
- `ENV key=value`: 设置容器中的环境变量
- `USE username`: 设置容器中运行命令的用户，默认使用root用户来运行命令
- `ONBUILD [INSTRUCTION]`: 添加镜像触发器，当该镜像被其他镜像作为基础镜像时，执行触发器
- `HEATHCHECK [OPTIONS] command`: 容器健康检查

构建过程

- 从基础镜像中运行一个容器
- 执行一条指令，对容器进行修改
- 执行类似docker commit的操作，提交一个新的镜像层
- 基于刚提交的新的镜像层，运行一个新的容器
- 再次执行Dockerfile中的下一条指令
- 反复执行上述过程，直到所有指令执行完毕
- `docker image build`会自动删除构建过程中运行的中间容器，但是不会删除构建过程中产生的中间层镜像，以方便使用缓存的镜像加快构建速度

构建Golang应用

```dockefile
FROM scratch
ADD main /
CMD ["/main"]
```