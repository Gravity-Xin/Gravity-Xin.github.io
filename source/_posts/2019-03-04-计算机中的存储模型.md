---
title: 计算机中的存储模型
date: 2019-03-04 16:33:22
categories: 
- Computer Architecture
tags: 
- Disk
- Memory
comments: true
---

计算机存储体系图

![img](/images/计算机中的存储模型.png)

## 内存

- 物理内存: 计算机实际的内存大小
  - 管理结构: 程序需要加载到内存中才可以执行。当多个进程进入内存之后，需要给其划分内存大小。一种方式是将内存进行等长度的划分，然后选择一部分分给进程；另一种方式是进程需要多少就给其划分多少，为不等长划分。因此需要使用某种数据结构来跟踪内存的使用情况
    - 等长: 使用`位图`来管理，将内存划分为大小相同的内存块，使用位图中的每一位来标记每一块的使用情况，从而形成一个位图
![img](/images/计算机中的存储模型之位图.png)
    - 不等长: 使用`空闲区表/空闲区链表`来管理，通过链式结构将内存的使用情况组织起来
![img](/images/计算机中的内存模型之空闲区表.png)
  - 分配算法 **以空闲区链表为例**
    - 首次适配: 在空闲区链表中从头开始查找符合申请内存大小的块，直到找到满足条件的为止。由于该算法不断从头开始申请内存，导致大部分使用的都是低地址空间的内存，从而留下了高地址空间来满足大内存的申请要求。缺点是较低的地址空间中频繁的申请和释放导致低地址空间存在较多内存碎片，同时每次都从头开始查找，查找效率较低
    - 下次适配: 是对首次适配算法的改进，即每次都上次适配的地址开始向下查找，而不是从头开始。该算法使得内存使用均匀，但是可能会导致不存在大的内存块来满足内存分配
    - 最佳适配: 首先按照空闲区大小从小到大进行排序，然后每次都从头开始匹配，这样保证每次分配的结果都是最优的。但是实际由于空闲区不一定与申请的内存大小完全相同，会导致产生很多较小的内存碎片，同时每次分配后都需要重新排序，开销较大
    - 最差适配: 首先按照空闲区大小从大到小进行排序，然后每次将最大空闲区内存块进行分配，然后如果空闲区过大，可以进行对空闲区进行二次分配。这样如果不能分配，则所有空闲区都不能分配
  - 回收算法 **一般来说，回收算法和分配算法是相关联的**
    - 四种情况: 从左往右从上往下分别为上相邻，下相邻，上下相邻和上下不相邻
![img](/images/计算机中的内存模型之内存回收.png)
  - 内存碎片问题: 指的是内存中占据一定大小的空间却无法被使用的内存，分为内碎片和外碎片
    - 内碎片: 比如按照页式等长分配，如果某进程需要5页多内存，那么只能给其分配6页内存，此时多余分配的不到1页的内存无法被其他进程使用，称为内碎片
    - 外碎片: 尚未被分配的且因为内存太小而无法被再次分配的内存块称为外碎片
    - 紧缩技术: 对内存碎片进行合并的方法。原理是将暂时不运行的进程安全的移动位置，独立出内存，从而将多个内存碎片进行组装得到一个较大的内存块
  - 伙伴算法: Linux系统内存分配和回收算法的实现。基本思想是将内存大小看做2的n次方，如果一个进程申请的内存块大小m满足`2^n-1 < m < 2^n`，则将此时的内存块进行分配。如下图，当进程需要200K空间时，1M等于1024K，如果m小于1M的一半，那么继续分离m，当分离到256时，刚好能满足200K的需求，所以进行分配。内存回收时，根据左右相邻的占用情况进行合并
![img](/images/计算机中的内存模型之伙伴算法.png)

- 虚拟内存: 进程运行于内存之中，每一个进程都有独立的内存地址空间。进程的内存地址空间是抽象出来的，属于虚拟内存
  - 特点
    - 将物理内存看做是磁盘的高速缓存，在物理内存中只保留活跃的数据并根据需要在物理内存和磁盘中进行数据交换，使得物理内存的使用更加高效
    - 为每一个进程抽象出一致的内存空间，使得多进程可以更加简单的运行；同时保证每一个进程的地址空间不会被其他进程破坏
  - 运行过程
    - 进程1在访问物理内存的数据时，首先获得的是虚拟内存地址空间的地址
    - 通过`MMU`将虚拟地址进行转换得到物理内存地址，从而获取数据
    - 由于物理内存空间有限，只需要将每一个进程常用的数据加载到内存之中，其他的数据先暂存到磁盘(Swap分区)上
    - 当进程在访问物理内存时，如果物理内存中的数据不存在，则发生中断，然后将磁盘上对应的数据加载到内存之中
![img](/images/计算机中的内存模型之虚拟内存.png)
  - 页式管理: 将物理内存、虚拟内存和磁盘上的交换分区都划分为固定大小的内存块，一般为4K。 **等长划分**
    - 页表: 对划分的内存块进行管理
![img](/images/计算机中的内存模型之页表.png)
      - 页表项: 页表中的每一项，包括地址转换和标记位。比如以x86架构的32位机器，地址总线为32位，寻址能力为2^32，页大小为4K，即2^12。因此我们需要(32-12)=20位来表示物理内存的页框号，即物理内存能够被分为2^20个页。标记位主要包括有效位，即该页面在物理内存中还是在磁盘上；访问位，即该页近期是否被访问过；修改位，即该页近期是否被修改过；保护位，即该页面是否属于操作系统，如果是则普通进程没有权限访问它
![img](/images/计算机中的内存模型之页表项.png)
![img](/images/计算机中的内存模型之页框号.png)
      - 单一页表: 页表必须连续存放，并且需要常驻内存，当地址空间很大时，页表会占用很大空间
      - 多级页表: 根据使用过的页面来建立页表，一级索引二级，二级索引内存
![img](/images/计算机中的内存模型之多级页表.png)
    - MMU: Memory Management Unit，是CPU管理虚拟存储器和物理存储器的控制线路，同时负责将虚拟地址转换为物理地址，以及提供硬件机制的内存访问授权
    - 快表TLB: 页表项的缓存，提高页面查询速度
    - 页错误/缺页异常: 当访问的页面在页表中没有记录或者页表项的有效位为0时，此时产生缺页异常，需要操作系统将磁盘上的数据交换到内存中
    - 页面置换算法: 针对内存和磁盘上数据的交换，目的是尽量减少页面交换和减少缺页异常，因为磁盘访问比较耗时
      - OPT: 理想页面置换算法，将未来不使用或很久以后才使用的页面置换出内存 **该算法并不能实现，仅仅是页面置换算法的一个衡量标准**
      - FIFO: 先进先出算法，将最早到来的页面置换出去，简单但不高效
      - 第二次机会: FIFO的一种改进，即当页面要被置换出去时，如果页表项中的访问位为1，则不置换，而是将访问我设置为0，同时将其放到队列末尾
      - 时钟算法: 对第二次机会算法的改进，将链式结构改为环形结构，这样就不需要出现将队头放入到队尾的这种比较耗时的操作
      - LRU: 最少使用算法，将近期使用次数最少的页置换出去
  - 段式管理: 将进程划分为若干个段进行存储，每一个段都是一个逻辑实体，比如程序段、数据段等。通过段表来进行管理，段表中包括段号、段起始点、装入位、段长度等。 **不等长划分**
  - 段/页式管理: 通过段表找到段，再通过段表中的段内偏移(实际是页框号加页内偏移)来找到页
![img](/images/计算机中的内存模型之段页式管理.png)
  - 内存映射: 使用`mmap`函数实现，该函数在内核中建立了文件与虚拟内存空间中某一段内存映射关系，这样该文件便脱离了磁盘文件系统的管理。进程在操作这一段内存时，操作系统自动将对应的数据写入到文件中，而不需要调用效率较低的`read`,`write`系统调用函数。同时也可以基于`mmap`实现不同进程间的文件共享
  - 写时复制: 使用`fork`函数创建子进程时，父子进程都通过各自的页表映射打牌物理内存上相同的页，但是当子进程修改内存数据时，由于页表上的访问权限位为只读，此时操作系统为子进程分配新的页

## 磁盘

- 磁盘结构: 通过磁头的转动来获取磁盘上的数据

![img](/images/计算机中的内存模型之磁盘结构1.png)
![img](/images/计算机中的内存模型之磁盘结构2.png)

- 磁盘存取: 通过磁盘控制器来存取数据；磁盘控制器将数据从磁盘读取到IO总线上，然后通过总线传送到内存中。内存此时可以看做是磁盘的一个高速缓存
  - 寻道时间: 将磁头组合定位到所在磁道的柱面上需要的时间
  - 旋转延迟: 等待访问块中第一个扇区转到磁头下的时间
  - 传输数据: 读写数据时，数据所在磁盘和扇区间的空隙经过磁头的时间

![img](/images/计算机中的内存模型之磁盘控制器.png)

- 磁盘调度
  - 调度算法: 磁盘本身也会根据内存的分页机制来进行分页；由于页面的请求顺序是随机的，但是磁盘控制器控制的磁头组合只有一个，因此需要通过磁盘调度算法实现在最短时间内完成最多的页面请求
    - FCFS: 先来先服务调度算法，将磁盘页面请求排成一个队列，先请求的先服务。优点是公平，缺点是效率太低
![img](/images/计算机中的内存模型之磁盘调度算法FCFS.png)
    - SSTF: 最短寻道时间算法，优先选择距离当前磁头最近的请求。优点是改善了平均请求耗时，缺点是不公平，比如某些距离磁头较远的请求可能长时间得不到响应
![img](/images/计算机中的内存模型之磁盘调度算法SSTF.png)
    - SCAN: 电梯调度算法，当有磁盘页面请求时，将磁头按一个方向移动，当该方向服务完毕后再转换方向，类似电梯。由于磁盘也是高速旋转设备，让它停止并转换方向也是非常耗时的
![img](/images/计算机中的内存模型之磁盘调度算法SCAN.png)

- 磁盘预读和缓冲: 提高磁盘访问的效率，减少磁盘IO的次数
  - 预读: 每次读取磁盘数据时，总会多读取相邻的几页数据。利用局部性读的原理，减少磁盘IO的次数
  - 缓冲: 每次写入磁盘时，并不是立即写入到磁盘中去，而是先添加到缓冲区中，等缓冲区满或有必要的时候再刷新到磁盘中去，减少磁盘IO的次数