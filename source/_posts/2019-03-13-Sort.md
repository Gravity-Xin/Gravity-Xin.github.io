---
title: Sort
date: 2019-03-13 10:00:20
categories: 
- Algo/DS
tags: 
- Sort 
comments: true
---

## 算法概述

可以分为两大类

- 比较类: 通过比较来决定元素间的相对次序，时间复杂度不能突破O(nlogn)，也称为非线性时间排序
  - 交换
    - 冒泡排序
    - 快速排序
  - 插入
    - 插入排序
    - 希尔排序
  - 选择
    - 选择排序
    - 堆排序
  - 归并
    - 二路归并排序
    - 多路归并排序
- 非比较类: 不通过比较来决定元素间的相对次数，时间复杂度可以突破O(nlogn)，以线性时间运行，也称为线性时间排序
  - 计数排序
  - 桶排序
  - 基数排序

时间复杂度

| 排序方法  | 平均时间复杂度  |  最坏时间复杂度 | 最好时间复杂度 | 空间复杂度| 稳定性 |
|----------|---------------|--------------|--------------|---------|-------|
| 冒泡排序  |     O(n^2)    |    O(n^2)    |    O(n)      |   O(1)  |  稳定  |
| 快速排序  |    O(nlogn)   |    O(n^2)    |    O(nlogn)  | O(nlogn)|  不稳定 |
| 插入排序  |    O(n^2)     |    O(n^2)    |    O(n)      |   O(1)  |  稳定  |
| 希尔排序  |    O(n^1.3)   |    O(n^2)    |    O(n)      |   O(1)  |  不稳定 |
| 选择排序  |    O(n^2)     |    O(n^2)    |    O(n^2)    |   O(1)  |  不稳定  |
|  堆排序   |   O(nlogn)   |   O(nlogn)   |    O(nlogn)  |   O(1)  |  不稳定  |
| 归并排序  |   O(nlogn)   |   O(nlogn)    |    O(nlogn)  |   O(n)  |   稳定  |
| 计数排序  |   O(n+k)     |    O(n+k)     |    O(n+k)    |   O(n+k) |  稳定  |
|  桶排序   |   O(n+k)     |    O(n^2)     |    O(n)      |   O(n+k) |  稳定  |
| 基数排序  |   O(n*k)     |    O(n*k)     |    O(n*k)    |   O(n+k) |  稳定  |

## 算法原理

n: 待排序的序列长度

- 冒泡排序(Bubble Sort)
  - 遍历一遍序列，依次比较相邻的两个元素，如果它们次序错误则将其进行交换，这样末尾的元素为最大
  - 除了最后一个元素之外，重复进行上述步骤
  - 当一次遍历中未发生交换操作或者遍历了n次后，整个序列有序

![img](/images/排序之冒泡排序.gif)

- 快速排序(Quick Sort): `递归分治法的思想`
  - 选择序列中的第一个元素作为基准
  - 进行分区操作，即遍历一遍序列，将所有元素小于该基准的放在基准前面，大于该基准的放在基准后面，此时该基准元素位于序列中正确的排序位置
  - 分别对基准元素前面和后面的子序列进行同样的操作，直到整个序列有序

![img](/images/排序之快速排序.gif)

- 插入排序(Insertion Sort)
  - 将序列上的第一个元素看做已经有序
  - 取出序列中的第二个元素作为待加入元素，在已有序的子序列中从后向前遍历
  - 如果子序列中的元素较大，则将其向后移位，直到待加入元素已经插入到正确位置，形成一个有序的子序列
  - 重复上述操作，直到整个序列有序

![img](/images/排序之插入排序.gif)

- 希尔排序(Shell Sort): `对插入排序的改进，通过设置不同的增量依次进行插入排序，也叫缩小增量排序`
  - 选择一个增量序列t1,t2,......,tk，其中ti>ti+1, tk=1
  - 对于每一个增量ti，将序列分割为ti个子序列，对各个子序列分别进行插入排序
  - 当增量为1时，其实是将整个序列作为一个子序列进行插入排序

![img](/images/排序之希尔排序.gif)

- 选择排序(Selection Sort)
  - 遍历一次序列，从中选择最小的元素，然后将其和序列中第一个元素进行交换
  - 此时序列中第一个元素有序，然后对剩下的元素再次进行上述操作，直到整个序列有序

![img](/images/排序之选择排序.gif)

- 堆排序(Heap Sort): `依赖堆数据结构` [Heap](https://gravity-xin.github.io/2018/11/12/Heap/)
  - 构造堆
  - 从堆中Pop堆顶元素，然后调整生成新的堆
  - 重复上述操作，直到排序完成

![img](/images/排序之堆排序.gif)

- 归并排序(Merge Sort): `递归分治法的思想，分为拆分子序列和合并子序列两个过程`
  - 将序列拆分为长度为n/2的子序列
  - 对每个子序列继续进行拆分，直到无法拆分为止
  - 对两个子序列进行合并，得到最终有序的序列

![img](/images/排序之归并排序.gif)

- 计数排序(Counting Sort): `要求序列中的元素为有确定范围的整数，将序列中的元素作为下标存储到额外开辟的数组空间中`
  - 确定输入序列中的最小元素和最大元素，构建额外的数组C，数组元素初始化为0
  - 对序列中的每一个值为i的元素，数组C的第i项的数组元素值加1
  - 遍历数组C，对于每一个数组元素i，每反向填充到序列一次就减1，直到为0

![img](/images/排序之计数排序.gif)

- 桶排序(Bucket Sort): `利用某个函数将序列中的元素映射到有限数量的桶中，然后对每一个分别进行排序，最后将元素进行拼接`
  - 设置确定数量的桶
  - 遍历序列，将其中的每一个元素分别映射到对应的桶中
  - 对于每一个桶使用某方法进行排序，比如快排
  - 将不为空的桶中的元素进行拼接

![img](/images/排序之桶排序.png)

- 基数排序(Radix Sort): `对序列中的元素先按照低位进行排序，然后再按照高位进行排序`
  - 获取序列中的最大元素，并获取其位数为n
  - 从最低位开始，取得序列中每个元素在该位的值，构建radix数组
  - 对radix数组进行计数排序
  - 重复上述步骤n次，最终得到有序序列

![img](/images/排序之基数排序.gif)