---
title: TCP/IP协议
date: 2019-02-12 17:36:12
categories: 
- Network
tags:
- ip
- tcp
- udp
---

TCP/IP是一个协议簇，有多个协议组成
从上往下，可以将TCP/IP分为四层，分别为

- 应用层: 负责向用户提供具体的应用服务 HTTP/DNS/FTP等 **应用层数据**
- 传输层: 负责两台计算机间的数据传输 TCP/UDP
  - TCP **TCP报文段(Segment)**
    - 提供字节流服务，使用包序号和重传机制实现可靠数据传输
    - 面向连接，使用SYNC、ACK标志位进行握手，使用FIN、ACK标志位进行挥手
    - 使用滑动窗口实现流量控制
    - 使用慢开始、拥塞避免、快重传和快恢复进行拥塞控制
  - UDP
    - 提供数据保温服务，不可靠
    - 不面向连接
- 网络层: 负责根据IP地址、MAC地址、ARP协议和路由对网络上数据包进行寻址 IP、TGMP、ICMP **IP数据报(Datagram)**
- 数据链路层: 负责网络连接的硬件部分 ARP、RARP和Ethernet等 **帧(Frame)**

![七层与四层模型](/images/TCP IP之七层与四层模型.png)

数据的流动在发送端为自上向下，在接收端为自下向上
在发送端的层与层之间传输数据时，每经过一层时会增加一个该层的首部信息；反之在接收端层与层之间传输时，每经过一层会把该层对应的首部消去

![数据通信过程](/images/TCP IP之数据通信过程.png)

- TCP首部格式

![TCP首部](/images/TCP首部格式.png)

- TCP的三次握手
  - TCP服务器进程创建传输控制块TCB, 时刻准备接受客户端进程的连接请求, 进入了LISTEN状态
  - TCP客户端进程创建传输控制块TCB, 然后向服务器发出连接请求报文，报文首部中的同步标志位SYN=1，同时选择一个初始序列号seq=x，此时TCP客户端进程进入了SYN-SENT状态
  - TCP服务器收到请求报文后, 如果同意连接, 则发出确认报文。确认报文中的ACK=1，SYN=1，ack=x+1，同时也要为自己初始化一个序列号seq=y，此时TCP服务器进程进入SYN-RCVD状态
  - TCP客户端进程收到确认后向服务器给出确认报文，报文的ACK=1，ack=y+1，seq=x+1
  - TCP连接建立，客户端进入ESTABLISHED状态。当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信

![TCP三次握手](/images/TCP三次握手.gif)

为什么不用两次握手?

为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误和浪费服务器资源。假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

- TCP的四次挥手
  - 客户端进程发出连接释放报文，并且停止发送数据。报文首部FIN=1，seq=u此时客户端进入FIN-WAIT-1（终止等待1）状态
  - 服务器收到连接释放报文，发出确认报文ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时服务端就进入了CLOSE-WAIT（关闭等待）状态
  - TCP服务器通知上层的应用进程，客户端向服务器的方向释放，此时处于半关闭状态，即客户端已经没有数据要发送了；但服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间
  - 客户端收到服务器的确认请求后，此时客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最终数据）
  - 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文FIN=1，确认序号为v+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认报文
  - 客户端收到服务器的连接释放报文后，必须发出确认报文ACK=1，ack=w+1，seq=u+1，此时客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态
  - 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些

![TCP四次挥手](/images/TCP四次挥手.gif)

为什么最后客户端还要等待2*MSL的时间呢?

MSL（Maximum Segment Lifetime），这是一个IP数据包能生存的最长时间，TCP允许不同的实现可以设置不同的MSL值。第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文