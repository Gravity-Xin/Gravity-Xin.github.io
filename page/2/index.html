<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Yihang&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Yihang&#39;s Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Yihang&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>Yihang's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Yihang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/Kubernetes基本使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/Kubernetes基本使用/" itemprop="url">Kubernetes基本使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T12:25:57+08:00">
                2019-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/系统架构/" itemprop="url" rel="index">
                    <span itemprop="name">系统架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/09/Kubernetes基本使用/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/09/Kubernetes基本使用/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Kubernetes中，主要通过Kubectl命令行工具对集群中的资源进行增删改查的操作，集群中的资源包括Pod、Service、各种控制器、Node等等</p>
<ul>
<li><code>Kubectl</code>的使用方式<ul>
<li>入门命令<ul>
<li><code>create</code>: 创建集群资源</li>
<li><code>expose</code>: 使用Pod、Service或各种控制器来创建Service资源，外部可以通过该Service实现对Pod的访问</li>
<li><code>run</code>: 在集群上运行特定镜像，创建Pod资源并使用Deployment或Job来对其进行控制</li>
<li><code>set</code>: 给集群中的特定资源进行配置，可以设置Pod中的环境变量、镜像名称、LabelSelector等</li>
</ul>
</li>
<li>中级命令<ul>
<li><code>get</code>: 查看集群中的各类资源的状态<ul>
<li><code>pod</code>: 查看Pod资源状态</li>
<li><code>deployment</code>: 查看Deployment控制器状态</li>
<li><code>service</code>: 查看Service资源状态</li>
</ul>
</li>
<li><code>explain</code>: 查看资源中各类资源的说明</li>
<li><code>edit</code>: 对集群中的资源对应的yaml文件进行编辑，保存后自动生效</li>
<li><code>delete</code>: 对集群中的资源进行删除</li>
</ul>
</li>
<li>部署管理<ul>
<li><code>rollout</code>: 对资源的更新部署进行管理，比如查看更新的状态，暂停和恢复更新，版本回滚等</li>
<li><code>rolling-update</code>: 对资源的部署进行滚动更新</li>
<li><code>scale</code>: 手动对资源进行扩容或缩容</li>
<li><code>autoscale</code>: 设置资源的自动水平伸缩</li>
</ul>
</li>
<li>集群管理<ul>
<li><code>certificate</code>: 修改集群认证信息</li>
<li><code>cluster-info</code>: 查询集群信息</li>
<li><code>top</code>: 查看集群中资源使用情况，如CPU、内存、磁盘等</li>
<li><code>cordon</code>: 标记集群中某节点不可被调度</li>
<li><code>uncordon</code>: 标记集群中某节点可以被调度</li>
<li><code>drain</code>: 将集群中某节点上运行的资源赶到其它节点上</li>
<li><code>taint</code>: 将集群中的某节点增加污点，与Pod的Toleration来配合使用，实现高级的调度</li>
</ul>
</li>
<li>故障排除和调试<ul>
<li><code>describe</code>: 显示集群某资源的详细信息<ul>
<li><code>pod</code>: 查看Pod的详细信息</li>
<li><code>service</code>: 查看Service的详细信息，以及Service对应Pod的EndPoints列表等</li>
</ul>
</li>
<li><code>logs</code>: 查看集群中某个Pod上的日志</li>
<li><code>attach</code>: 附加到某个Pod中</li>
<li><code>exec</code>: 在某个Pod中运行命令</li>
<li><code>port-forward</code>: 设置某个Pod的端口和本地端口的映射</li>
<li><code>proxy</code>: 在本地启动对集群API Server的代理</li>
<li><code>cp</code>: 在<code>Pod</code>和本地之间进行文件拷贝</li>
<li><code>auth</code>: 进行操作权限的校验</li>
</ul>
</li>
<li>高级命令<ul>
<li><code>apply</code>: 对集群中的资源进行配置</li>
<li><code>patch</code>: 更新集群中的资源配置</li>
<li><code>replace</code>: 对集群中的资源进行替换</li>
<li><code>convert</code>: 将配置文件转换为不同的API版本</li>
</ul>
</li>
<li>资源管理<ul>
<li><code>label</code>: 给资源添加Label</li>
<li><code>annotate</code>: 给资源添加Annotation</li>
<li><code>completion</code>: 输出不同Shell的自动补全配置</li>
</ul>
</li>
<li>其它<ul>
<li><code>api-versions</code>: 输出集群支持的API群组</li>
<li><code>api-resources</code>: 输出集群支持的资源信息</li>
<li><code>config</code>: 修改Kubectl使用的kubeconfig文件</li>
<li><code>plugin</code>: 给集群添加插件</li>
<li><code>version</code>: 输出客户端和服务端的版本信息</li>
<li><code>cluster_info</code>: 查看集群中Master上系统Service信息</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/Kubernetes网络基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/Kubernetes网络基础/" itemprop="url">Kubernetes网络基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T15:57:50+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/系统架构/" itemprop="url" rel="index">
                    <span itemprop="name">系统架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/08/Kubernetes网络基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/08/Kubernetes网络基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>三种网络<ul>
<li>节点网络: 所有Node组成的网络，是真实有效的IP地址，与物理网卡或虚拟网卡绑定</li>
<li>集群网络: 所有Service组成的网络，是虚拟的IP地址，不与物理网卡或虚拟网卡绑定。通过DNS对Service名称进行解析，通过在iptables、ipvs中添加规则实现对Pod的访问</li>
<li>Pod网络: 所有Pod组成的网络，是真是有效的IP地址，与虚拟网卡绑定</li>
</ul>
</li>
</ul>
<p>三者处于不同的网段中，外部的访问分别经过节点网络、集群网络和Pod网络  <strong>所有的网络相关，其本质上都是iptables或者ipvs中的规则在起作用，以及dns解析在起作用</strong></p>
<p><img src="/images/Kubernetes之三种网络.png" alt="img"></p>
<ul>
<li><p>三种通信</p>
<ul>
<li>Pod内部的多个容器间使用联盟式网络，共享网络设备，可以直接通过localhost进行访问</li>
<li>Pod与Pod的容器之间<ul>
<li>两个Pod如果位于同一个Node上，容器间可以利用<code>docker0</code>网桥相连接进行通信</li>
<li>两个Pod如果在不同Node上，此时容器分别被<code>docker0</code>网桥隐藏，无法直接连接，此时需要Flannel来接管Pod的IP分配，以Overlay Network叠加式网络的方式进行连接</li>
</ul>
</li>
<li>Pod与Service之间，由于Service在K8S集群中有独立的IP地址和DNS名称，可以通过其与Service直接进行通信</li>
</ul>
</li>
<li><p>网络配置和网络策略: 提供了<code>CNI</code>容器网络接口规范，可以将第三方插件纳入到集群中</p>
<ul>
<li>网络配置: Pod和Service的IP分配</li>
<li>网络策略: Pod之间是否可以互相访问</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/07/Docker容器的资源管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/07/Docker容器的资源管理/" itemprop="url">Docker容器的资源管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-07T17:49:55+08:00">
                2019-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/系统架构/" itemprop="url" rel="index">
                    <span itemprop="name">系统架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/07/Docker容器的资源管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/07/Docker容器的资源管理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>默认情况下，Docker对容器使用的资源是没有限制的，容器可以随意使用宿主机上的内存、CPU、IO等系统资源</p>
<p>在使用<code>docker container run</code>来运行容器时，可以通过一些选项来显式对容器使用的资源进行限制</p>
<ul>
<li><p>内存资源限制</p>
<ul>
<li><code>--memory</code>: 容器占用的内存限制值<code>M</code>，最小为4m</li>
<li><code>--memory-reservation</code>: 设置容器预留的内存大小</li>
<li><code>--memory-swap</code>: 容器占用的交换空间大小<code>S</code>，即可使用的swap大小等于<code>M-S</code>，只有当<code>M</code>设置后该选项才可以设置。设置为-1表示不限制交换空间大小。</li>
<li><code>--memory-swappiness</code>: 设置交换空间的倾向性</li>
<li><code>--kernel-memory</code>: 设置容器中的内核占用的内存限制</li>
<li><code>--oom-kill-disable</code>: 设置容器禁止被OOM-KILL</li>
</ul>
</li>
<li><p>CPU资源限制</p>
<ul>
<li><code>--cpus</code>: 设置容器可以使用的CPU数量，此时并不是一直占用某些个CPU，而是占用的CPU的比例之和为该值</li>
<li><code>--cpu-period</code>和<code>--cpu-quota</code>: 两者配合使用，前者指定CPU运行周期，后者指定容器占用的CPU周期；可以理解为<code>quota/period</code>等于第一个选项值</li>
<li><code>--cpuset-cpus</code>: 设置容器始终在某些个CPU上运行</li>
<li><code>--cpu-shares</code>: 设置容器占用的CPU权重，只有当CPU资源不充足时，该选项才起作用</li>
</ul>
</li>
</ul>
<p>可以使用<code>docker-stress</code>镜像对上述参数进行测试，使用<code>docker container stats</code>来查看容器内的资源使用情况</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/数据结构-Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/数据结构-Tree/" itemprop="url">数据结构-Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T15:19:27+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程技术/" itemprop="url" rel="index">
                    <span itemprop="name">编程技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/05/数据结构-Tree/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/05/数据结构-Tree/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li><p>定义:每一个节点至多有两颗子树，子树有左右之分</p>
</li>
<li><p>特点</p>
<ul>
<li>第i层最多含有2^(i-1)个节点</li>
<li>深度为k的二叉树，最多还有2^k-1个节点</li>
<li>如果叶子节点数为n0，度为2的节点数为n2，则n0=n2+1</li>
</ul>
</li>
<li><p>满二叉树: 除了最后一层节点无子节点外，其他所有节点都有两个子节点</p>
</li>
<li><p>完全二叉树: 除最后一层外，其他层的所有节点数都达到最大数量，且最后一层的所有节点都连续集中在最左边</p>
</li>
</ul>
<p><img src="/images/Tree数据结构之满-完全二叉树.png" alt="img"></p>
<ul>
<li><p>遍历</p>
<ul>
<li>先序遍历: 根 左子树 右子树</li>
<li>中序遍历: 左子树 根 右子树</li>
<li>后序遍历: 左子树 右子树 根</li>
</ul>
</li>
<li><p>存储方式</p>
<ul>
<li>顺序存储: 利用数组来存储，仅仅适用于完全二叉树，如堆数据结构，此时父子节点的编号存在对应关系<br><img src="/images/Tree数据结构之顺序存储.png" alt="img"></li>
<li>链式存储: 最常见的存储方式，由于子节点可能为空，所以该方式比较浪费存储空间<br><img src="/images/Tree数据结构之链式存储.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><ul>
<li><p>定义</p>
<ul>
<li>如果左子树不为空，则左子树上所有节点的值都小于根节点的值</li>
<li>如果右子树不为空，则右子树上所有节点的值都大于根节点的值</li>
<li>左右子树本身也是一颗二叉查找树</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>对其进行中序遍历，则得到一个有序的序列</li>
<li>插入/查找操作的时间复杂度为O(logn)，最坏情况下为O(n) <strong>原因在于在插入和删除元素时，没有保持树的平衡</strong></li>
<li>二叉查找树的高度决定了二叉查找树的效率</li>
</ul>
</li>
<li><p>查找过程</p>
<ul>
<li>如果根节点为空，则返回查找失败</li>
<li>如果根节点的值等于查找值，返回成功</li>
<li>如果查找的元素小于根节点，则到左子树中查找</li>
<li>如果查找的元素大于根节点，则到右子树中查找</li>
</ul>
</li>
<li><p>插入过程</p>
<ul>
<li>如果根节点为空，则插入的元素为根节点</li>
<li>如果根节点的值等于查找值，返回失败</li>
<li>如果插入的元素小于根节点，则插入到左子树中</li>
<li>如果插入的元素大于根节点，则插入到右子树中</li>
</ul>
</li>
<li><p>删除过程</p>
<ul>
<li>使用查找过程找到对应的节点P</li>
<li>如果P节点的左右子树都为空，直接删除该节点并修改其父节点的指针值<br><img src="/images/Tree数据结构之二叉查找树的删除1.png" alt="img"></li>
<li>如果P节点的左子树或右子树为空，则让P节点的子节点与父节点相连，然后删除P节点即可<br><img src="/images/Tree数据结构之二叉查找树的删除2.png" alt="img"></li>
<li>如果P节点左右子树均不为空，则找到P右子树中最小的元素或者找到左子树中最大的元素，然后将其放到P节点位置即可<br><img src="/images/Tree数据结构之二叉查找树的删除3.png" alt="img"></li>
</ul>
</li>
</ul>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><ul>
<li>定义<ul>
<li>是对二叉查找树的改进，通过<strong>在插入和删除过程中进行自平衡的操作，保证二叉树的高度为logn，从而提高查找效率</strong></li>
<li>任意节点的左右两个子树的高度差的绝对值不超过1</li>
<li>左右子树本身也是平衡二叉树</li>
</ul>
</li>
</ul>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><p>平衡二叉树的一种</p>
<ul>
<li>特点<ul>
<li>插入/删除/查找的时间复杂度O(logn)</li>
<li>在进行插入和删除时，需要通过一次或多次旋转操作来保持平衡，该树结构是高度平衡的</li>
</ul>
</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>平衡二叉树的一种</p>
<ul>
<li>特点<ul>
<li>插入/删除/查找的时间复杂度O(logn)，需要通过自平衡操作来保证平衡</li>
<li>每一个节点带有颜色属性，红色或黑色</li>
<li>根节点和所有叶子节点都是黑色</li>
<li>每一个红色节点必须含有两个黑色的子节点 <strong>即从根节点要叶子节点之间的所有路径中不可以有两个连续的红色节点，即红节点的孩子不能是红节点</strong></li>
<li><strong>从任一节点到其每一个叶子节点的所有路径中都包含相同数目的黑色节点</strong></li>
<li><strong>从根节点到叶子节点的最长路径不多于最短路径的两倍</strong>，该树结构是大致平衡的</li>
</ul>
</li>
</ul>
<p><img src="/images/Tree数据结构之红黑树.png" alt="img"></p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><ul>
<li>定义<ul>
<li>中间节点最多只有M个子节点，M&gt;2</li>
<li>根节点的子节点数为[2, M]</li>
<li>中间节点的子节点数为[M/2, M]</li>
<li>每一个节点上存放至少M/2-1(向上取整)和至多M-1个关键字</li>
<li>中间节点的关键字数量=指向子节点的指针数量-1</li>
<li>中间节点的关键字为K[1], K[2], … ,k[M-1]，且K[i]&lt;K[i+1]</li>
<li>中间节点指向子节点的指针为P[1], P[2], … , P[M]，其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1], K[i])的子树</li>
</ul>
</li>
</ul>
<p><img src="/images/Tree数据结构之B树.png" alt="img"></p>
<ul>
<li><p>特点</p>
<ul>
<li>是一种用于查找的平衡树，但不是二叉树。节点的子节点数量可以超过2个，是一个更为一般的二叉查找树</li>
<li>用于对排序后的数据进行存储，插入/删除/查找的时间复杂度为O(logn)</li>
<li><strong>平衡二叉树是通过在插入/删除过程中进行自平衡的操作保持树的平衡，从而提高查找效率；而B树是通过增加子节点的数量，减少树的高度来提高查找效率</strong></li>
</ul>
</li>
<li><p>查找过程</p>
<ul>
<li>如果根节点为空，则返回查找失败</li>
<li>如果根节点的值等于查找值，返回成功</li>
<li>由于根节点的子节点是有序的，因此在根节点的子节点中进行顺序或者二分查找，如果找到查找值，返回成功；否则确定查找值位于Ki与Ki+1之间，此时Pi为根节点的第i个子节点</li>
<li>取Pi作为根节点，重复上述查找过程</li>
</ul>
</li>
</ul>
<h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><ul>
<li>定义<ul>
<li>是B树的变体，也是用于查找的平衡树，定义除了以下几点，其他与B树基本相同</li>
<li>中间节点的指针数和关键字相同</li>
<li>中间节点的子树指针P[i], 指向关键字属于[K[i], K[i+1])的子树</li>
<li>所有叶子节点增加一个链指针</li>
<li>所有关键字都出现在叶子节点</li>
</ul>
</li>
</ul>
<p><img src="/images/Tree数据结构之B+树.png" alt="img"></p>
<ul>
<li><p>特点</p>
<ul>
<li>所有关键字都出现在叶子节点，因此在进行查找时必须到达叶子节点才能命中，而B树可以在非叶子节点命中</li>
<li>所有叶子节点之间形成一个链表，且链表中的关键字是有序的</li>
<li>中间节点可以看做是叶子节点的索引层，叶子节点可以看做是存储关键字(数据)的数据层</li>
<li><strong>由于根节点和中间节点不存储数据，因此占用空间较小，更适合进行外部存储，比如磁盘，因为一次磁盘IO可以读取更多的节点数。同时，由于所有数据都在叶子节点上，可以方便进行范围查找，并且可以通过磁盘预读的方式和局部性原理减少磁盘IO的次数，提高查找效率</strong></li>
</ul>
</li>
<li><p>查找过程</p>
<ul>
<li>和B树相同，只不过只有在叶子节点上才会命中</li>
</ul>
</li>
</ul>
<h2 id="单词查找树"><a href="#单词查找树" class="headerlink" title="单词查找树"></a>单词查找树</h2><ul>
<li>定义<ul>
<li>又叫Trie树，主要用于统计、排序和存储大量的字符串，常被搜索引擎用于文本词频统计</li>
<li><strong>使用字符串的公共前缀来减少查询时间</strong>，最大限度减少无谓的字符串比较</li>
</ul>
</li>
</ul>
<p><img src="/images/Tree数据结构之单次查找树.png" alt="img"></p>
<ul>
<li>特点<ul>
<li>根节点不包含字符，其他节点只包含一个字符，即每一个节点最多有26个子节点</li>
<li>从根节点到某一个节点，路径上经过的字符连接起来即为该节点对应的字符串</li>
<li>每一个节点的所有子节点包含的字符都不相同</li>
</ul>
</li>
</ul>
<h2 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h2><ul>
<li><p>定义</p>
<ul>
<li>构造所有节点的带权路径之和最小的二叉树</li>
<li>可用于进行霍夫曼编码</li>
</ul>
</li>
<li><p>构造过程</p>
</li>
</ul>
<p><img src="/images/Tree数据结构之霍夫曼树.png" alt="img"></p>
<ul>
<li>霍夫曼编码</li>
</ul>
<p><img src="/images/Tree数据结构之霍夫曼编码.png" alt="img"></p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><ul>
<li>AVL、红黑树和B树、B+树的区别</li>
</ul>
<p>都是用于查找的树结构，<strong>AVL和红黑树是平衡二叉树，通过自平衡操作来实现树的平衡，提高查找效率；而B树、B+树是多叉树，通过降低树的高度来提交查找效率</strong></p>
<p>当数据量较小时，AVL和红黑树的性能很好；但是当数据量很大时，如数据库中的数据，性能则不够理想</p>
<p>原因在于当数据里很大时，此时内存不够用，需要将大部分的数据存储到磁盘之中，此时磁盘的IO就成为了性能瓶颈。AVL和红黑树的数据结构无法迎合磁盘IO中的预读机制，导致<strong>在查询过程中需要h次磁盘IO，h为树的高度</strong>。同时AVL和红黑树在插入和删除过程中需要进行自平衡的操作，如果此时部分数据在内存、部分数据在磁盘中时<strong>无法完成自平衡操作</strong></p>
<p>而B树和B+树的设计迎合的磁盘IO的预读机制。通过在节点上添加多个子节点，<strong>降低了树的高度，需要的磁盘IO次数变小</strong>；同时在新建节点时，可以将<strong>多个节点的大小等于磁盘上的一页，这样便可以通过磁盘预读机制，一次性读取多个节点，减少磁盘IO次数</strong></p>
<ul>
<li>B树和B+树的区别</li>
</ul>
<p>B+树只在叶子节点上存放数据，因此查找时间复杂度固定为O(logn)，而B树查询的时间复杂度不定，与关键字在树中的位置有关，最好为O(1)</p>
<p>B+树叶子节点使用链表来组织，可以充分利用磁盘预读的空间局部性原理，减少磁盘IO数，同时可方便的进行<strong>范围查询</strong>；而B-树不方便进行范围查询</p>
<p>B+树的中间节点不存放数据，<strong>节点占用空间更小，因此单次磁盘IO可以读取的节点数更大</strong>，因此查找效率更高</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/计算机中的存储模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/计算机中的存储模型/" itemprop="url">计算机中的存储模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T16:33:22+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/系统架构/" itemprop="url" rel="index">
                    <span itemprop="name">系统架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/04/计算机中的存储模型/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/04/计算机中的存储模型/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>计算机存储体系图</p>
<p><img src="/images/计算机中的存储模型.png" alt="img"></p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul>
<li><p>物理内存: 计算机实际的内存大小</p>
<ul>
<li>管理结构: 程序需要加载到内存中才可以执行。当多个进程进入内存之后，需要给其划分内存大小。一种方式是将内存进行等长度的划分，然后选择一部分分给进程；另一种方式是进程需要多少就给其划分多少，为不等长划分。因此需要使用某种数据结构来跟踪内存的使用情况<ul>
<li>等长: 使用<code>位图</code>来管理，将内存划分为大小相同的内存块，使用位图中的每一位来标记每一块的使用情况，从而形成一个位图<br><img src="/images/计算机中的存储模型之位图.png" alt="img"></li>
<li>不等长: 使用<code>空闲区表/空闲区链表</code>来管理，通过链式结构将内存的使用情况组织起来<br><img src="/images/计算机中的内存模型之空闲区表.png" alt="img"></li>
</ul>
</li>
<li>分配算法 <strong>以空闲区链表为例</strong><ul>
<li>首次适配: 在空闲区链表中从头开始查找符合申请内存大小的块，直到找到满足条件的为止。由于该算法不断从头开始申请内存，导致大部分使用的都是低地址空间的内存，从而留下了高地址空间来满足大内存的申请要求。缺点是较低的地址空间中频繁的申请和释放导致低地址空间存在较多内存碎片，同时每次都从头开始查找，查找效率较低</li>
<li>下次适配: 是对首次适配算法的改进，即每次都上次适配的地址开始向下查找，而不是从头开始。该算法使得内存使用均匀，但是可能会导致不存在大的内存块来满足内存分配</li>
<li>最佳适配: 首先按照空闲区大小从小到大进行排序，然后每次都从头开始匹配，这样保证每次分配的结果都是最优的。但是实际由于空闲区不一定与申请的内存大小完全相同，会导致产生很多较小的内存碎片，同时每次分配后都需要重新排序，开销较大</li>
<li>最差适配: 首先按照空闲区大小从大到小进行排序，然后每次将最大空闲区内存块进行分配，然后如果空闲区过大，可以进行对空闲区进行二次分配。这样如果不能分配，则所有空闲区都不能分配</li>
</ul>
</li>
<li>回收算法 <strong>一般来说，回收算法和分配算法是相关联的</strong><ul>
<li>四种情况: 从左往右从上往下分别为上相邻，下相邻，上下相邻和上下不相邻<br><img src="/images/计算机中的内存模型之内存回收.png" alt="img"></li>
</ul>
</li>
<li>内存碎片问题: 指的是内存中占据一定大小的空间却无法被使用的内存，分为内碎片和外碎片<ul>
<li>内碎片: 比如按照页式等长分配，如果某进程需要5页多内存，那么只能给其分配6页内存，此时多余分配的不到1页的内存无法被其他进程使用，称为内碎片</li>
<li>外碎片: 尚未被分配的且因为内存太小而无法被再次分配的内存块称为外碎片</li>
<li>紧缩技术: 对内存碎片进行合并的方法。原理是将暂时不运行的进程安全的移动位置，独立出内存，从而将多个内存碎片进行组装得到一个较大的内存块</li>
</ul>
</li>
<li>伙伴算法: Linux系统内存分配和回收算法的实现。基本思想是将内存大小看做2的n次方，如果一个进程申请的内存块大小m满足<code>2^n-1 &lt; m &lt; 2^n</code>，则将此时的内存块进行分配。如下图，当进程需要200K空间时，1M等于1024K，如果m小于1M的一半，那么继续分离m，当分离到256时，刚好能满足200K的需求，所以进行分配。内存回收时，根据左右相邻的占用情况进行合并<br><img src="/images/计算机中的内存模型之伙伴算法.png" alt="img"></li>
</ul>
</li>
<li><p>虚拟内存: 进程运行于内存之中，每一个进程都有独立的内存地址空间。进程的内存地址空间是抽象出来的，属于虚拟内存</p>
<ul>
<li>特点<ul>
<li>将物理内存看做是磁盘的高速缓存，在物理内存中只保留活跃的数据并根据需要在物理内存和磁盘中进行数据交换，使得物理内存的使用更加高效</li>
<li>为每一个进程抽象出一致的内存空间，使得多进程可以更加简单的运行；同时保证每一个进程的地址空间不会被其他进程破坏</li>
</ul>
</li>
<li>运行过程<ul>
<li>进程1在访问物理内存的数据时，首先获得的是虚拟内存地址空间的地址</li>
<li>通过<code>MMU</code>将虚拟地址进行转换得到物理内存地址，从而获取数据</li>
<li>由于物理内存空间有限，只需要将每一个进程常用的数据加载到内存之中，其他的数据先暂存到磁盘(Swap分区)上</li>
<li>当进程在访问物理内存时，如果物理内存中的数据不存在，则发生中断，然后将磁盘上对应的数据加载到内存之中<br><img src="/images/计算机中的内存模型之虚拟内存.png" alt="img"></li>
</ul>
</li>
<li>页式管理: 将物理内存、虚拟内存和磁盘上的交换分区都划分为固定大小的内存块，一般为4K。 <strong>等长划分</strong><ul>
<li>页表: 对划分的内存块进行管理<br><img src="/images/计算机中的内存模型之页表.png" alt="img"><ul>
<li>页表项: 页表中的每一项，包括地址转换和标记位。比如以x86架构的32位机器，地址总线为32位，寻址能力为2^32，页大小为4K，即2^12。因此我们需要(32-12)=20位来表示物理内存的页框号，即物理内存能够被分为2^20个页。标记位主要包括有效位，即该页面在物理内存中还是在磁盘上；访问位，即该页近期是否被访问过；修改位，即该页近期是否被修改过；保护位，即该页面是否属于操作系统，如果是则普通进程没有权限访问它<br><img src="/images/计算机中的内存模型之页表项.png" alt="img"><br><img src="/images/计算机中的内存模型之页框号.png" alt="img"></li>
<li>单一页表: 页表必须连续存放，并且需要常驻内存，当地址空间很大时，页表会占用很大空间</li>
<li>多级页表: 根据使用过的页面来建立页表，一级索引二级，二级索引内存<br><img src="/images/计算机中的内存模型之多级页表.png" alt="img"></li>
</ul>
</li>
<li>MMU: Memory Management Unit，是CPU管理虚拟存储器和物理存储器的控制线路，同时负责将虚拟地址转换为物理地址，以及提供硬件机制的内存访问授权</li>
<li>快表TLB: 页表项的缓存，提高页面查询速度</li>
<li>页错误/缺页异常: 当访问的页面在页表中没有记录或者页表项的有效位为0时，此时产生缺页异常，需要操作系统将磁盘上的数据交换到内存中</li>
<li>页面置换算法: 针对内存和磁盘上数据的交换，目的是尽量减少页面交换和减少缺页异常，因为磁盘访问比较耗时<ul>
<li>OPT: 理想页面置换算法，将未来不使用或很久以后才使用的页面置换出内存 <strong>该算法并不能实现，仅仅是页面置换算法的一个衡量标准</strong></li>
<li>FIFO: 先进先出算法，将最早到来的页面置换出去，简单但不高效</li>
<li>第二次机会: FIFO的一种改进，即当页面要被置换出去时，如果页表项中的访问位为1，则不置换，而是将访问我设置为0，同时将其放到队列末尾</li>
<li>时钟算法: 对第二次机会算法的改进，将链式结构改为环形结构，这样就不需要出现将队头放入到队尾的这种比较耗时的操作</li>
<li>LRU: 最少使用算法，将近期使用次数最少的页置换出去</li>
</ul>
</li>
</ul>
</li>
<li>段式管理: 将进程划分为若干个段进行存储，每一个段都是一个逻辑实体，比如程序段、数据段等。通过段表来进行管理，段表中包括段号、段起始点、装入位、段长度等。 <strong>不等长划分</strong></li>
<li>段/页式管理: 通过段表找到段，再通过段表中的段内偏移(实际是页框号加页内偏移)来找到页<br><img src="/images/计算机中的内存模型之段页式管理.png" alt="img"></li>
<li>内存映射: 使用<code>mmap</code>函数实现，该函数在内核中建立了文件与虚拟内存空间中某一段内存映射关系，这样该文件便脱离了磁盘文件系统的管理。进程在操作这一段内存时，操作系统自动将对应的数据写入到文件中，而不需要调用效率较低的<code>read</code>,<code>write</code>系统调用函数。同时也可以基于<code>mmap</code>实现不同进程间的文件共享</li>
<li>写时复制: 使用<code>fork</code>函数创建子进程时，父子进程都通过各自的页表映射打牌物理内存上相同的页，但是当子进程修改内存数据时，由于页表上的访问权限位为只读，此时操作系统为子进程分配新的页</li>
</ul>
</li>
</ul>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h2><ul>
<li>磁盘结构: 通过磁头的转动来获取磁盘上的数据</li>
</ul>
<p><img src="/images/计算机中的内存模型之磁盘结构1.png" alt="img"><br><img src="/images/计算机中的内存模型之磁盘结构2.png" alt="img"></p>
<ul>
<li>磁盘存取: 通过磁盘控制器来存取数据；磁盘控制器将数据从磁盘读取到IO总线上，然后通过总线传送到内存中。内存此时可以看做是磁盘的一个高速缓存<ul>
<li>寻道时间: 将磁头组合定位到所在磁道的柱面上需要的时间</li>
<li>旋转延迟: 等待访问块中第一个扇区转到磁头下的时间</li>
<li>传输数据: 读写数据时，数据所在磁盘和扇区间的空隙经过磁头的时间</li>
</ul>
</li>
</ul>
<p><img src="/images/计算机中的内存模型之磁盘控制器.png" alt="img"></p>
<ul>
<li><p>磁盘调度</p>
<ul>
<li>调度算法: 磁盘本身也会根据内存的分页机制来进行分页；由于页面的请求顺序是随机的，但是磁盘控制器控制的磁头组合只有一个，因此需要通过磁盘调度算法实现在最短时间内完成最多的页面请求<ul>
<li>FCFS: 先来先服务调度算法，将磁盘页面请求排成一个队列，先请求的先服务。优点是公平，缺点是效率太低<br><img src="/images/计算机中的内存模型之磁盘调度算法FCFS.png" alt="img"></li>
<li>SSTF: 最短寻道时间算法，优先选择距离当前磁头最近的请求。优点是改善了平均请求耗时，缺点是不公平，比如某些距离磁头较远的请求可能长时间得不到响应<br><img src="/images/计算机中的内存模型之磁盘调度算法SSTF.png" alt="img"></li>
<li>SCAN: 电梯调度算法，当有磁盘页面请求时，将磁头按一个方向移动，当该方向服务完毕后再转换方向，类似电梯。由于磁盘也是高速旋转设备，让它停止并转换方向也是非常耗时的<br><img src="/images/计算机中的内存模型之磁盘调度算法SCAN.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘预读和缓冲: 提高磁盘访问的效率，减少磁盘IO的次数</p>
<ul>
<li>预读: 每次读取磁盘数据时，总会多读取相邻的几页数据。利用局部性原理，减少磁盘IO的次数</li>
<li>缓冲: 每次写入磁盘时，并不是立即写入到磁盘中去，而是先添加到缓冲区中，等缓冲区满或有必要的时候再刷新到磁盘中去，减少磁盘IO的次数</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/优秀博客收藏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/优秀博客收藏/" itemprop="url">优秀博客收藏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T10:26:27+08:00">
                2019-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/阅读分享/" itemprop="url" rel="index">
                    <span itemprop="name">阅读分享</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/04/优秀博客收藏/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/04/优秀博客收藏/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>Go语言中的协程调度</li>
</ul>
<p><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html" target="_blank" rel="noopener">OS Scheduler</a></p>
<p><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html" target="_blank" rel="noopener">Go Scheduler</a></p>
<p><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html" target="_blank" rel="noopener">Concurrency</a></p>
<ul>
<li>Mysql中InnoDB和MyISAM的索引设计和实现<br><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">Mysql Index</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/01/LevelDB-入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/01/LevelDB-入门/" itemprop="url">LevelDB-入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-01T14:27:34+08:00">
                2019-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/系统架构/" itemprop="url" rel="index">
                    <span itemprop="name">系统架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/01/LevelDB-入门/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/03/01/LevelDB-入门/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>可以持久化的本地KV存储系统，当内存占用较大时，会将部分数据存储到磁盘中</li>
<li>存入的数据按照key值进行有序排序，相邻的key在存储文件中顺序存储；可以自定义key比较规则</li>
<li>提供基本的读、写、删除操作，也提供针对多个key的批量原子操作</li>
<li>支持数据快照(snapshot)功能，支持数据压缩功能</li>
<li>写操作远远快于读操作，顺序读写操作远远快于随机读写操作</li>
</ul>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p><img src="/images/LevelDB之整体结构.png" alt="img"></p>
<h2 id="静态角度"><a href="#静态角度" class="headerlink" title="静态角度"></a>静态角度</h2><ul>
<li>内存中的Memtable: 写入操作的KV记录先保存在其中；占用的内存大小有上限</li>
<li>内存中的Immutable Memtable: 只可读，不可写和删除</li>
<li>磁盘中的Current文件: 记录当前Manifest文件名称，因为Manifest文件随着LevelDB的运行和SSTable的变化，会生成新的Manifest文件来记录该变化</li>
<li>磁盘中的Manifest文件: 记录各个SSTable文件的管理信息，如文件所属level、文件名称、最小和最大Key等</li>
<li>磁盘中的Log文件: 对写入操作进行记录；当系统崩溃后，如果内存中的某些数据尚未保存到磁盘中，可以使用其进行数据的恢复</li>
<li>磁盘中的SSTable文件: 文件中的Key是有序的 <strong>level0的SSTable文件(后缀为.sst)和其它level的文件相比有特殊性，该层级内的多个.sst文件可能存在key重叠</strong></li>
</ul>
<h3 id="Log文件"><a href="#Log文件" class="headerlink" title="Log文件"></a>Log文件</h3><p>Log文件:</p>
<p><img src="/images/LevelDB之Log文件.png" alt="img"></p>
<p>Record:</p>
<p><img src="/images/LevelDB之Record.png" alt="img"></p>
<ul>
<li>物理上来看，是以32KB为单位的物理Block，每一个Block为基本读取单位；一个Log文件就是连续32KB大小的Block构成的</li>
<li>逻辑上来看，一条KV记录看做是一条Record<ul>
<li>CheckSum: 对类型字段和数据字段的校验码</li>
<li>记录长度: 数据的大小</li>
<li>类型: 每条记录的逻辑结构和Log文件物理Block之间的关系</li>
<li>数据: KV对</li>
</ul>
</li>
</ul>
<h3 id="SSTable文件"><a href="#SSTable文件" class="headerlink" title="SSTable文件"></a>SSTable文件</h3><p>Log文件中的Key是无序的，凡是SSTable文件中的Key是有序的</p>
<p>物理布局:</p>
<p><img src="/images/LevelDB之SSTable的物理布局.png" alt="img"></p>
<p>逻辑布局:</p>
<p><img src="/images/LevelDB之SSTable的逻辑布局.png" alt="img"></p>
<ul>
<li><p>物理上来看，与Log文件一样，分为固定大小的Block</p>
<ul>
<li>数据存储区</li>
<li>压缩算法类型</li>
<li>数据校验码</li>
</ul>
</li>
<li><p>逻辑上来看，分为数据存储区和数据管理区</p>
<ul>
<li>数据存储区: 存放实际的KV对<ul>
<li>有序的KV记录</li>
<li>重启点信息: 由于Key有序，相邻Key有可能部分内容存在重叠，为了减少存储空间，可以将相同部分记录在第一个Key中，后续Key只需要记录不同部分。<code>重启点</code>表示从这条记录开始，不再采取只记录不同Key部分，而是重新记录所有的Key值</li>
<li>重启点数量</li>
</ul>
</li>
<li>数据管理区: 索引指针等管理数据，方便快速查找相应记录<ul>
<li>元数据区</li>
<li>元数据区索引</li>
<li>数据索引区: 红色部分记录大于等于数据块i中最大Key值的那个Key，第二个字段指出数据块i在SSTable文件中的起始位置，第三个字段指出数据块i的大小</li>
<li>文件尾部区</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>数据存储区:</p>
<p><img src="/images/LevelDB之数据存储区.png" alt="img"></p>
<p>KV记录:</p>
<p><img src="/images/LevelDB之数据KV记录.png" alt="img"></p>
<p>数据索引区:</p>
<p><img src="/images/LevelDB之数据索引区.png" alt="img"></p>
<p>文件尾部区:</p>
<p><img src="/images/LevelDB之文件尾部区.png" alt="img"></p>
<h3 id="Memtable-Immutable-Memtable"><a href="#Memtable-Immutable-Memtable" class="headerlink" title="Memtable/Immutable Memtable"></a>Memtable/Immutable Memtable</h3><p>Memtable和Immutable Memtable的结构是完全相同的，唯一区别在于后者是可读但不可写和删除</p>
<p>提供了读、写和删除的操作接口；实际上并不会真正进行删除操作，而是将删除操作作为插入一条记录而实现的，同时将Key加上删除标记，真正的删除操作在后续写入磁盘的压缩操作中进行</p>
<p>Memtable中的Key是有序的，<strong>实际实现的数据结构是SkipList</strong></p>
<h2 id="动态角度"><a href="#动态角度" class="headerlink" title="动态角度"></a>动态角度</h2><p>读、写、删除操作的执行过程，数据压缩的过程以及系统崩溃后的恢复过程</p>
<ul>
<li>写入<ul>
<li>先对Log文件进行追加写操作，成功后写入到Memtable中(更新跳跃表结构)；一次写入涉及一次磁盘顺序写和一次内存写入，故写入操作速度快</li>
</ul>
</li>
</ul>
<p><img src="/images/LevelDB之写入操作.png" alt="img"></p>
<ul>
<li><p>删除</p>
<ul>
<li>与写入操作相同，但不是真正执行删除操作，而是写入<code>Key:删除标记</code>，在后台的压缩操作中真正执行删除操作</li>
</ul>
</li>
<li><p>读取</p>
<ul>
<li>依次从Memtable、Immutable Memtable和SSTable进行读取</li>
<li>按照数据的新鲜程度来决定查找顺序，Level i+1的数据时Level i的数据经过压缩操作后得到的</li>
<li>Level 0和其它Level中查找某个key的过程是不一样的。因为Level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的查找策略是先找出Level 0中哪些文件包含这个key(通过Manifest问卷)，之后按照文件的新鲜程度排序，依次查找，读出key对应的value。而如果是非Level 0的话，因为这个Level的文件之间key是不重叠的，所以只需要从一个文件就可以找到key对应的value</li>
<li>对于SSTable，LevelDB具体的查找过程: 先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取;如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后LevelDB根据索引定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个Level的SSTable文件并不包含这个key，然后到下一级别的SSTable中去查找</li>
<li>读取操作涉及的操作较多，效率没有写入快 <strong>因此LevelDB更适合写操作大于读操作，顺序读取较多的情况</strong></li>
</ul>
</li>
</ul>
<p><img src="/images/LevelDB之读取操作.png" alt="img"></p>
<ul>
<li>压缩<ul>
<li>当Memtable占用的内存大小达到上限时，需要将内存中的数据保存到磁盘中。此时，会生成新的Log文件和Memtable，原先的Memtable变为Immutable Memtable，而后续到来的数据将被保存到新的Log文件和Memtable中</li>
<li>将Immutable Memtable中的数据导入至磁盘中，并进行压缩操作，最终形成一个SSTable文件</li>
<li>SSTable文件随着内存数据的不断导出和压缩，形成一种层级结构，这也是称为LevelDB的原因</li>
<li>压缩操作主要用来删除无效Key，减少数据规模，降低磁盘占用</li>
<li>压缩的类型包括两种<ul>
<li>minor<ul>
<li>将Immutable Memtable中的数据直接导入到SSTable文件中</li>
<li>由于Immutable Table是一个多层级的跳跃表，其中的记录是根据key有序排列的，所以minor压缩就是按照Key由小到大遍历，并依次写入一个Level 0 的新建SSTable文件中，写完后建立文件的index数据</li>
<li>由此可以看出Level 0的多个文件中，可能存在key范围的重叠</li>
</ul>
</li>
<li>major<ul>
<li>当某个Level下的SSTable文件数目超过一定值后，会从这个Level的SSTable中选择一个或多个文件，将其和Level+1的SSTable文件合并</li>
<li>对于大于Level 0的层级，选择其中一个文件就行；但是对于Level 0来说，如果指定一个文件的话，本Level中很可能有其他SSTable文件的key范围和这个文件有重叠，因此需要找出所有有重叠的文件和Level 1的文件进行合并</li>
<li>对多个文件采用多路归并排序的方式进行合并</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/LevelDB之压缩操作.png" alt="img"></p>
<ul>
<li>缓存<ul>
<li>如果读取操作如果没有在Memtable中找到记录，则要多次进行磁盘访问操作；使用缓存来降低磁盘访问次数，提高查找效率</li>
<li>引入了两个不同的缓存<ul>
<li>Table Cache<ul>
<li>Key值是SSTable的文件名称</li>
<li>Value<ul>
<li>指向磁盘打开的SSTable文件的文件指针</li>
<li>指向内存中这个SSTable文件对应的Table结构指针，其中保存了SSTable的Index内容以及用来指示Block Cache的CacheID</li>
</ul>
</li>
</ul>
</li>
<li>Block Cache<ul>
<li>Key是文件的CacheID加上Block在文件中的起始位置BlockOffset</li>
<li>Value是Block的内容</li>
</ul>
</li>
</ul>
</li>
<li>如果读取的数据的局部性比较好，则大部分内容都能在Cache中读到，可以提高读取效率；如果是随机读取，则性能较差</li>
</ul>
</li>
</ul>
<p>Table Cache:</p>
<p><img src="/images/LevelDB之Table缓存.png" alt="img"></p>
<p>Block Cache:</p>
<p><img src="/images/LevelDB之Block缓存.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/Docker网络基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/Docker网络基础/" itemprop="url">Docker网络基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-28T11:42:16+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/系统架构/" itemprop="url" rel="index">
                    <span itemprop="name">系统架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/28/Docker网络基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/28/Docker网络基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Docker提供的网络模式"><a href="#Docker提供的网络模式" class="headerlink" title="Docker提供的网络模式"></a>Docker提供的网络模式</h2><p><img src="/images/Docker之网络模式.png" alt="img"></p>
<ul>
<li><p>Bridge(默认模式): 创建名为<code>docker0</code>, IP地址为<code>172.17.0.1</code>的虚拟网桥，默认为NAT桥，在iptables中定义了数据转发的规则  <strong>桥接式网络</strong></p>
<ul>
<li>该网桥可以当交换机使用，如果网桥还设置了IP地址则还可以当网卡使用</li>
<li>当启动一个容器时，给容器分配IP地址和一对虚拟网卡设备，一端在容器中，一端在桥上(此时网桥当做交换机使用)</li>
<li>同一个宿主机上的多个容器之间，默认是可以互相访问的(都是使用<code>docker0</code>作为交换机，且网段相同)</li>
<li>宿主机本身将<code>docker0</code>网桥看做IP为<code>172.17.0.1</code>的网卡，也可以与容器进行通信</li>
<li>由于容器本身被NAT桥隐藏，因此外部主机(物理机或容器)默认是无法访问宿主机上的容器的</li>
<li>为了让外部主机访问宿主机上的容器，需要使用DNAT方式，即在iptables中添加一个转发规则，当外部主机访问宿主机上的某个端口时该请求被转发到对应容器中  <strong>Docker中的端口映射</strong></li>
</ul>
</li>
<li><p>Container: 多个容器间共享<code>Network</code>, <code>UTS</code>和<code>IPC</code>命名空间，容器间共享网络协议栈和网络虚拟设备  <strong>联盟式网络</strong></p>
<ul>
<li>同一个宿主机之间的容器，可以直接通过<code>localhost</code>或<code>127.0.0.1</code>进行访问</li>
</ul>
</li>
<li><p>Host: 容器与宿主机共享<code>Network</code>命名空间，网络协议栈和网络设备与宿主机相同，没有独立的IP地址  <strong>开放式网络</strong></p>
</li>
<li><p>None: 容器中使用独立的<code>Network</code>命名空间，但是没有网络设备和配置  <strong>封闭式网络</strong></p>
<ul>
<li>只有<code>localhost</code>网络接口</li>
<li>一般该容器主要是用例进行批处理的任务，不需要与外部进行网络通信</li>
</ul>
</li>
<li><p>Overlay</p>
</li>
<li><p>自定义网络: <code>docker network create</code>命令自定义创建网络。如果创建的网络的模式为Bridge的话，此时会新建一个新的类似于<code>docker0</code>的网桥</p>
</li>
</ul>
<h2 id="网络模式的使用"><a href="#网络模式的使用" class="headerlink" title="网络模式的使用"></a>网络模式的使用</h2><ul>
<li><p><code>docker network ls</code>: 显示Docker支持的网络</p>
</li>
<li><p><code>docker network create</code>: 创建指定类型的网络</p>
</li>
<li><p><code>docker network inspect</code>: 查看Docker网络使用的网络模式</p>
</li>
<li><p><code>docker container create|run</code>命令</p>
<ul>
<li><code>--network</code>选项<ul>
<li><code>--network bridge</code>: 设置容器使用Bridge模式的网络</li>
<li><code>--network host</code>: 设置容器使用Host模式的网络</li>
<li><code>--network none</code>: 设置容器使用None模式的网络</li>
<li><code>--network container:containerName</code>: 设置与名称为containerName的容器共享Network命名空间</li>
</ul>
</li>
<li><code>--host</code>选项: 设置容器的主机名，通过查看<code>/etc/hosts</code>或<code>hostname</code>命令来确认主机名</li>
<li><code>--dns</code>选项: 设置容器的DNS服务器地址，通过查看<code>/etc/resolv.conf</code>来确认DNS服务器地址</li>
<li><code>--add-host</code>选项: 增加主机名称和IP地址的映射关系，向hosts文件中写入DNS解析结果，通过查看<code>/etc/hosts</code>来确认</li>
<li><code>-p</code>选项: 使用DNAT的方式，将容器内的端口和宿主机上的端口进行映射，可以通过<code>docker container port</code>命令查看映射结果 <strong>本质是在iptables中增加数据转发规则</strong><ul>
<li><code>-p containerPort</code>: 将指定容器的端口映射到宿主机所有地址上的一个动态随机端口</li>
<li><code>-p hostPort:containerPort</code>: 将指定容器的端口映射到宿主机所有地址上的指定端口</li>
<li><code>-p ip::containerPort</code>: 将指定容器的端口映射到宿主机指定地址上的动态随机端口</li>
<li><code>-p ip:hostPort:containerPort</code>: 将指定容器的端口映射到宿主机上指定地址上的指定端口</li>
</ul>
</li>
</ul>
</li>
<li><p><code>docker container inspect</code>: 查看容器使用的网络</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/28/Docker镜像容器基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/28/Docker镜像容器基础/" itemprop="url">Docker镜像容器基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-28T10:03:40+08:00">
                2019-02-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/系统架构/" itemprop="url" rel="index">
                    <span itemprop="name">系统架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/28/Docker镜像容器基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/28/Docker镜像容器基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Docker镜像包含启动一个容器所需要的文件系统及其内容</p>
<h2 id="镜像和容器的本质"><a href="#镜像和容器的本质" class="headerlink" title="镜像和容器的本质"></a>镜像和容器的本质</h2><ul>
<li><p>采用分层构建机制，最底层为bootfs，其上为rootfs</p>
<ul>
<li>bootfs: 用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约内存资源</li>
<li>rootfs: 位于bootfs之上，是容器的根文件系统；rootfs由内核挂载为只读模式，然后通过<code>联合挂载</code>技术额为挂载一个可写层</li>
</ul>
</li>
<li><p>一个镜像可以看做包含多个只读层，然后通过联合文件系统(Union File System)技术将不同的层整合成一个文件系统</p>
<ul>
<li>多个只读层对用户是透明的，用户看到的就是一个文件系统</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之镜像的本质.png" alt="img"></p>
<ul>
<li>由此，提出了镜像层的概念<ul>
<li>一个镜像可以看做包含多个镜像层，可以使用<code>docker image history</code>来查看镜像层信息</li>
<li>每一层除了包含自身内容，还包含一些元数据信息和指向下一层的指针，可以使用<code>docker image inspect</code>来查看元数据信息</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之镜像层.png" alt="img"></p>
<ul>
<li>一个未被运行的容器的定义几乎和镜像是一模一样，唯一区别在于<strong>容器的最上面的镜像层是可读写的</strong></li>
</ul>
<p><img src="/images/Docker之容器的本质.png" alt="img"></p>
<ul>
<li>因此，未被运行的容器 = 镜像 + 读写层</li>
</ul>
<p><img src="/images/Docker之镜像和容器的区别.png" alt="img"></p>
<ul>
<li>一个处于运行状态的容器被定义为一个可读写的文件系统、隔离的进程空间及其中包含的进程</li>
</ul>
<p><img src="/images/Docker之运行的容器的本质.png" alt="img"></p>
<ul>
<li>通过文件系统隔离技术，容器中的进程对文件系统的修改、删除和创建等操作，仅仅作用于最上层的可读写镜像层，不会影响下层</li>
</ul>
<p><img src="/images/Docker之容器对文件的修改.png" alt="img"></p>
<h2 id="对镜像和容器操作命令的理解"><a href="#对镜像和容器操作命令的理解" class="headerlink" title="对镜像和容器操作命令的理解"></a>对镜像和容器操作命令的理解</h2><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><ul>
<li><code>docker image ls</code><ul>
<li>列出所有镜像中的镜像层信息</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之image ls命令.png" alt="img"></p>
<p><img src="/images/Docker之image ls -a命令.png" alt="img"></p>
<ul>
<li><code>docker image rm</code><ul>
<li>将镜像中的只读层软删除(当该层不再被使用时才会真正删除)</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之image rm命令.png" alt="img"></p>
<ul>
<li><code>docker image build</code><ul>
<li>反复执行<code>docker container run</code>, 修改可读写层、<code>docker commit</code></li>
<li>在每一次循环中生成一个新的层，最终得到一个镜像</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之image build命令.png" alt="img"></p>
<ul>
<li><code>docker image save</code><ul>
<li>将镜像中的镜像层进行压缩，同时保存每一层的元数据信息</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之image save命令.png" alt="img"></p>
<ul>
<li><code>docker image history</code><ul>
<li>递归输出镜像中的各个镜像层</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之image history命令.png" alt="img"></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><ul>
<li><code>docker container create</code><ul>
<li>在指定的镜像最上层添加一个可读写层，生成一个新的容器</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container create命令.png" alt="img"></p>
<ul>
<li><code>docker container start</code><ul>
<li>为容器中的文件系统创建一个进程隔离空间，并在其中运行进程</li>
<li>一个容器只可以有一个进程隔离空间</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container start命令.png" alt="img"></p>
<ul>
<li><code>docker container run</code><ul>
<li>先添加可读写层；再创建进程隔离空间并运行进程</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container run命令.png" alt="img"></p>
<ul>
<li><code>docker container ls</code><ul>
<li>列出所有容器D</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container ls命令.png" alt="img"></p>
<p><img src="/images/Docker之container ls -a命令.png" alt="img"></p>
<ul>
<li><code>docker container stop</code><ul>
<li>向容器进程隔离空间中进程发送SIGTERM信号，然后停止所有的进程</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container stop命令.png" alt="img"></p>
<ul>
<li><code>docker container kill</code><ul>
<li>向容器进程隔离空间中进程发送SIGKILL信号</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container kill命令.png" alt="img"></p>
<ul>
<li><code>docker container pause</code><ul>
<li>使用cgroups的特性将容器的进程隔离空间暂停</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container pause命令.png" alt="img"></p>
<ul>
<li><code>docker container rm</code><ul>
<li>将容器中的可读写层删除，只可以对处于非运行状态的容器执行</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container rm命令.png" alt="img"></p>
<ul>
<li><code>docker container commit</code><ul>
<li>将容器中的可读写层转换为只读层，从而将容器转换为镜像</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container commit命令.png" alt="img"></p>
<ul>
<li><code>docker container exec</code><ul>
<li>在容器的进程隔离空间中启动一个新进程</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container exec命令.png" alt="img"></p>
<ul>
<li><code>docker container|image inspect</code><ul>
<li>提取容器或镜像中最顶层镜像层的元数据信息</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container image inspect命令.png" alt="img"></p>
<ul>
<li><code>docker container export</code><ul>
<li>将容器中的镜像层进行整合，移除不必要的层和元数据，得到一个层</li>
</ul>
</li>
</ul>
<p><img src="/images/Docker之container export命令.png" alt="img"></p>
<h2 id="分层镜像与联合挂载技术"><a href="#分层镜像与联合挂载技术" class="headerlink" title="分层镜像与联合挂载技术"></a>分层镜像与联合挂载技术</h2><ul>
<li>Aufs</li>
<li>overlayfs</li>
<li>btrfs</li>
<li>devicemapper</li>
<li>vfs</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/数据结构-SkipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yihang">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yihang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/数据结构-SkipList/" itemprop="url">数据结构-SkipList</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T14:41:34+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程技术/" itemprop="url" rel="index">
                    <span itemprop="name">编程技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/02/22/数据结构-SkipList/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/02/22/数据结构-SkipList/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>经常使用的用于快速查找的平衡有序数据结构包括:</p>
<ul>
<li>AVL树</li>
<li>红黑树</li>
<li>B树</li>
</ul>
<p>这些数据结构的实现往往比较复杂</p>
<p>而在开源的Redis和LevelDB等软件中，使用了SkipList（跳跃表）这一数据结构来作为平衡有序数据结构。SkipList的原理简单，实现容易，且操作效率与其他数据结构差距不大。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul>
<li>有序列表的搜索: 二分查找</li>
</ul>
<p><img src="/images/SkipList之有序列表.png" alt="img"></p>
<ul>
<li>随机化提取某些节点</li>
</ul>
<p><img src="/images/SkipList之提取某些元素1.png" alt="img"></p>
<ul>
<li>继续随机化提取某些节点</li>
</ul>
<p><img src="/images/SkipList之提取某些元素2.png" alt="img"></p>
<p>SkipList使用这些随机化提取的元素作为查找时的索引，这样在搜索时可以提高查找的效率</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>有很多层结构组成</li>
<li>每一层都是有序链表</li>
<li>最底层包含所有元素</li>
<li>如果一个元素出现在第i层链表中，则也会出现在第i层之下的链表中</li>
<li>每一个元素节点包含两个指针，一个指向同层链表的下一个元素，一个指向下一层链表的元素</li>
</ul>
<p><img src="/images/SkipList之整体结构.png" alt="img"></p>
<ul>
<li><p>查找元素X</p>
<ul>
<li>在每一层进行查找，设置查找起点P为根节点</li>
<li>当P为空指针时，返回查找失败</li>
<li>当P.Next.Value等于X时，返回成功；当P.Next.Value小于X时，P设置为P.Next，返回第二步</li>
</ul>
</li>
<li><p>添加元素</p>
<ul>
<li>确定每一层需要添加的元素，一共需要占据n层（随机值）</li>
<li>使用查找过程在每一层确定查出需要插入的位置</li>
<li>在插入位置后分别插入元素，调整指针值</li>
</ul>
</li>
<li><p>删除元素</p>
<ul>
<li>在每一层查找元素，获取节点</li>
<li>删除该节点元素，调整指针指向</li>
</ul>
</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node 跳跃表中元素</span></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    key   <span class="keyword">uint64</span>      <span class="comment">// 节点元素key</span></span><br><span class="line">    value <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 节点元素值</span></span><br><span class="line">    level <span class="keyword">int</span>         <span class="comment">// 当前节点的层数</span></span><br><span class="line">    next  *Node       <span class="comment">// 当前元素指向的当前层次的下一个元素</span></span><br><span class="line">    prev  *Node       <span class="comment">// 当前元素指向的当前层次的前一个元素</span></span><br><span class="line">    down  *Node       <span class="comment">// 当前元素指向的下一层的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewNode 创建新的跳跃表元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNode</span><span class="params">(key <span class="keyword">uint64</span>, value <span class="keyword">interface</span>&#123;&#125;, level <span class="keyword">int</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Node&#123;</span><br><span class="line">        key:   key,</span><br><span class="line">        value: value,</span><br><span class="line">        level: level,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SkipList 跳跃表</span></span><br><span class="line"><span class="keyword">type</span> SkipList <span class="keyword">struct</span> &#123;</span><br><span class="line">    level <span class="keyword">int</span>     <span class="comment">// 跳跃表的层数</span></span><br><span class="line">    size  <span class="keyword">int32</span>   <span class="comment">// 跳跃表中元素的数量</span></span><br><span class="line">    head  []*Node <span class="comment">// 跳跃表的头元素列表</span></span><br><span class="line">    tail  []*Node <span class="comment">// 跳跃表的尾元素列表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSkipList 创建跳跃表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSkipList</span><span class="params">(level <span class="keyword">int</span>)</span> *<span class="title">SkipList</span></span> &#123;</span><br><span class="line">    s := &amp;SkipList&#123;</span><br><span class="line">        level: level,</span><br><span class="line">    &#125;</span><br><span class="line">    s.head = <span class="built_in">make</span>([]*Node, level, level)</span><br><span class="line">    s.tail = <span class="built_in">make</span>([]*Node, level, level)</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; level; j++ &#123;</span><br><span class="line">        s.head[j] = NewNode(<span class="number">0</span>, <span class="literal">nil</span>, level)</span><br><span class="line">        s.tail[j] = NewNode(<span class="number">0</span>, <span class="literal">nil</span>, level)</span><br><span class="line">        s.head[j].next = s.tail[j]</span><br><span class="line">        s.tail[j].next = <span class="literal">nil</span></span><br><span class="line">        s.head[j].prev = <span class="literal">nil</span></span><br><span class="line">        s.tail[j].prev = s.head[j]</span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">            s.head[j].down = <span class="literal">nil</span></span><br><span class="line">            s.tail[j].down = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.head[j].down = s.head[j<span class="number">-1</span>]</span><br><span class="line">            s.tail[j].down = s.tail[j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Search 在跳跃表进行查找</span></span><br><span class="line"><span class="comment">// 如果node为nil，说明查找失败</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SkipList)</span> <span class="title">Search</span><span class="params">(key <span class="keyword">uint64</span>)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> key &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pNode *Node</span><br><span class="line">    <span class="keyword">for</span> i := s.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123; <span class="comment">// 从最高层向下查找</span></span><br><span class="line">        pNode = s.head[i]</span><br><span class="line">        <span class="keyword">for</span> pNode != <span class="literal">nil</span> &amp;&amp; pNode != s.tail[i] &#123;</span><br><span class="line">            <span class="keyword">if</span> pNode.key == key &#123;</span><br><span class="line">                <span class="keyword">return</span> pNode</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pNode.key &lt; key &#123;</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert 在跳跃表上进行插入</span></span><br><span class="line"><span class="comment">// 如果元素已存在，则进行更新操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SkipList)</span> <span class="title">Insert</span><span class="params">(key <span class="keyword">uint64</span>, value <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> key &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    previousNodes := <span class="built_in">make</span>([]*Node, s.level) <span class="comment">// 在每一层上待插入元素的前置元素</span></span><br><span class="line">    bFind := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> pNode *Node</span><br><span class="line">    <span class="keyword">for</span> i := s.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123; <span class="comment">// 从最高层向下查找</span></span><br><span class="line">        pNode = s.head[i]</span><br><span class="line">        <span class="keyword">for</span> pNode != <span class="literal">nil</span> &amp;&amp; pNode != s.tail[i] &#123;</span><br><span class="line">            <span class="keyword">if</span> pNode.key == key &#123;</span><br><span class="line">                bFind = <span class="literal">true</span> <span class="comment">// 如果找到了节点，则只需要将节点的值更新，不再需要前置元素列表</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pNode.key &lt; key &#123;</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pNode = pNode.prev</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bFind &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> pNode == s.tail[i] &#123;</span><br><span class="line">            previousNodes[i] = pNode.prev</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            previousNodes[i] = pNode <span class="comment">// 将当前层的前置元素插入到列表中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bFind &#123; <span class="comment">// 如果查找到该元素，则对其进行更新操作</span></span><br><span class="line">        <span class="keyword">for</span> pNode != <span class="literal">nil</span> &#123;</span><br><span class="line">            pNode.value = value</span><br><span class="line">            pNode = pNode.down</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        level := randomLevel(s.level)</span><br><span class="line">        <span class="keyword">var</span> downNode *Node</span><br><span class="line">        <span class="keyword">for</span> l := <span class="number">0</span>; l &lt; level; l++ &#123; <span class="comment">// 插入元素并更新next和down指针</span></span><br><span class="line">            newNode := NewNode(key, value, level)</span><br><span class="line">            newNode.next = previousNodes[l].next</span><br><span class="line">            newNode.prev = previousNodes[l]</span><br><span class="line">            previousNodes[l].next = newNode</span><br><span class="line">            newNode.next.prev = newNode</span><br><span class="line">            newNode.down = downNode</span><br><span class="line">            downNode = newNode</span><br><span class="line">        &#125;</span><br><span class="line">        atomic.AddInt32(&amp;s.size, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 从跳跃表中删除元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SkipList)</span> <span class="title">Delete</span><span class="params">(key <span class="keyword">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pNode *Node</span><br><span class="line">    bFind := <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> i := s.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123; <span class="comment">// 从最高层向下查找</span></span><br><span class="line">        pNode = s.head[i]</span><br><span class="line">        <span class="keyword">for</span> pNode != <span class="literal">nil</span> &amp;&amp; pNode != s.tail[i] &#123;</span><br><span class="line">            <span class="keyword">if</span> pNode.key == key &#123;</span><br><span class="line">                bFind = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> pNode.key &lt; key &#123;</span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pNode = pNode.down</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> bFind &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> bFind &#123; <span class="comment">// 如果查找到该元素，则对其进行删除操作</span></span><br><span class="line">        <span class="keyword">for</span> pNode != <span class="literal">nil</span> &#123;</span><br><span class="line">            pNode.prev.next = pNode.next</span><br><span class="line">            pNode.next.prev = pNode.prev</span><br><span class="line">            pNode = pNode.down</span><br><span class="line">        &#125;</span><br><span class="line">        atomic.AddInt32(&amp;s.size, <span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成[1, n]的随机数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomLevel</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">    <span class="keyword">return</span> rand.Intn(n) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续可以优化的点:</p>
<ul>
<li>使用shard方法(基于key进行hash)对跳跃表中的元素进行分组，提高并发读写的效率</li>
<li>使用读写锁进行并发读写的保护</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yihang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">81</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">142</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yihang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"comment"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  





  

  

  

  
  

  

  

  

</body>
</html>
